<html lang="en"><head>
<title>Pcb</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name=description content="Pcb">
<meta name=generator content="makeinfo 4.0">
<link href="http://texinfo.org/" rel=generator-home>
</head><body>

<p><hr>
Node:<a name="Top">Top</a>,
Next:<a rel=next href="#Copying">Copying</a>,
Previous:<a rel=previous href="#(dir)">(dir)</a>,
Up:<a rel=up href="#(dir)">(dir)</a>
<br>

<h1>Pcb</h1>

<p>This document is a manual for <code>Pcb</code>, the interactive printed circuit
board layout system for <code>X11</code>.

<ul>
<li><a href="#Copying">Copying</a>:                 <code>Pcb</code> is freely redistributable! 
<li><a href="#History">History</a>:                 How it all began. 
<li><a href="#Overview">Overview</a>:                An overview of <code>Pcb</code>. 
<li><a href="#Intro">Intro</a>:                   A short description of the basic objects. 
<li><a href="#Getting%20Started">Getting Started</a>:         Introduction to <code>Pcb</code>. 
<li><a href="#User%20Commands">User Commands</a>:           User commands of <code>Pcb</code>. 
<li><a href="#Command-Line%20Options">Command-Line Options</a>:    Calling <code>Pcb</code> from a shell. 
<li><a href="#X11%20Interface">X11 Interface</a>:           Action routines, resources and default translation. 
<li><a href="#File%20Formats">File Formats</a>:            Description of <code>ASCII</code> files used by <code>Pcb</code>. 
<li><a href="#Library%20Creation">Library Creation</a>:        Detailed description of symbol library creation. 
<li><a href="#Schematic%20Frontends">Schematic Frontends</a>:     Schematic capture programs that work with PCB. 
<li><a href="#Installation">Installation</a>:            Compiling, installing and troubleshooting. 
<li><a href="#Custom%20Menus">Custom Menus</a>:            Customizing the menu bar. 
<li><a href="#Index">Index</a>:                   The Index. 
</ul>

<p><hr>
Node:<a name="Copying">Copying</a>,
Next:<a rel=next href="#History">History</a>,
Previous:<a rel=previous href="#Top">Top</a>,
Up:<a rel=up href="#Top">Top</a>
<br>

<h1>Copying</h1>

<p>Copyright &copy; 1994,1995,1996,1997 Thomas Nau

<p>Copyright &copy; 1998,1999,2000,2001,2002 harry eaton

<p>This program is free software; you may redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

<p>This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANT-ABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
<b>GNU General Public License</b> for more details.

<p><hr>
Node:<a name="History">History</a>,
Next:<a rel=next href="#Overview">Overview</a>,
Previous:<a rel=previous href="#Copying">Copying</a>,
Up:<a rel=up href="#Top">Top</a>
<br>

<h1>History</h1>

<p><code>Pcb</code> is a handy tool for laying out printed circuit
boards.

<p><code>Pcb</code> was first written by Thomas Nau for an Atari ST in 1990 and
ported to <code>UNIX</code> and <code>X11</code> in 1994. 
It was not intended as a professional layout system,
but as a tool which supports people who do some
home-developing of hardware.

<p>The second release 1.2 included menus for the first time. This made
<code>PCB</code> easier to use and thus a more important tool.

<p>Release 1.3 introduced undo for highly-destructive commands,
more straightforward action handling and scalable fonts. Layer-groups
were introduced to group signal-layers together.

<p>Release 1.4 provided support for add-on device drivers. 
Two layers (the solder and the component side)
were added to support SMD elements. The handling of libraries
was also improved in 1.4.1. Support for additional devices like
GERBER plotters started in 1.4.4. The undo feature was expanded
and the redo-feature added in 1.4.5.

<p>harry eaton took over pcb development begining with Release 1.5,
although he contributed some code beginning with Release 1.4.3

<p>Release 1.5 provides support for rats-nest generation from simple net
lists.  It also allows for automatic clearances around pins that pierce
a polygon.  A variety of other enhancments including a Gerber RS274X
driver and NC drill file generation have also been added.

<p>Release 1.6 provides automatic screen updates of changed regions. 
This should elliminate most of the need for the redraw ((<em>R</em> key). 
Also some changes to what order items under the cursor are selected
were made for better consistancy - it is no longer possible to
accidentally move a line or line point that is completely obscured
by a polygon laying over top of it.  Larger objects on the upper
most layers can be selected ahead of smaller objects on lower layers. 
These changes make operations more intuitive.  A new mode of line
creation was added that creates two line on 45 degree angles
with a single click. The actual outline of the prospective line(s) are
now shown during line creation.  An arc creation mode was added. 
Drawn arcs are quarter circles and can be useful for high frequency
controlled impedance lines.  (You can have eighth circle arc if the
source is compiled with -DARC45, but be aware that the ends of such
arcs can never intersect a grid point).  Two new flags for pins and
vias were created - one indicates that the pin or via is purely a
drill hole and has no copper annulus.  You can only toggle this flag
for vias - for elements, it must be an integral part of the element
definition.  The other flag controls whether the pad will be round
or octagonal.  There is also now a feature for converting the contents
of a buffer into an element.

<p>Release 1.6.1 added the ability to make groups of action commands bound to
a single X11 event to be undone by a single undo. Also a simple design rule
checker was added - it checks for minimum spacing and overlap rules. Plus
many fixes for bugs introduced with the many changes of 1.6

<p>Release 1.7 added support for routing tracks through polygons without touching
them. It also added support for unplated drill files, and drawing directly
on the silk layer. A Netlist window for easily working with netlist was also added.

<p>Release 2.0 adds an auto-router, a new simpler library mechanism, much improved
support for graphically creating (and editing) elements, viewable solder-mask
layers (and editing), snap to pins and pads, netlist entry by drawing rats, element
files (and libraries) that can contain whole sub-layouts, metric grids, improved
user interface, a GNU autoconf/automake based build system, and a host
of other improvements.

<p>Special thanks goes to:
<pre>Thomas Nau (who started the project and wrote the early versions).
C. Scott Ananian (who wrote the auto-router code).
Bernhard Daeubler (Bernhard.Daeubler@physik.uni-ulm.de)
Harald Daeubler (Harald.Daeubler@physik.uni-ulm.de)
DJ Delorie (djdelorie@users.sourceforge.net)
Larry Doolittle (ldoolitt@recycle.lbl.gov)
Dan McMahill (danmc@users.sourceforge.net)
Roland Merk (merk@faw.uni-ulm.de)
Erland Unruh (Erland.Unruh@malmo.trab.se)
Albert John FitzPatrick III (ajf_nylorac@acm.org)
Boerge Strand (borges@ifi.uio.no)
Andre M. Hedrick (hedrick@Astro.Dyer.Vanderbilt.Edu)
</pre>

<br>who provided all sorts of help including porting <code>PCB</code> to<br>
<p>several operating systems and platforms, bug fixes, library enhancement,
user interface suggestions and more. In addition to these people,
many others donated time for bug-fixing and
other important work. Some of them can be identified in the source code
files.  Thanks to all of them. If you feel left out of this list, I
appologize; please send me an e-mail and I'll try to correct the omission.

<p><hr>
Node:<a name="Overview">Overview</a>,
Next:<a rel=next href="#Intro">Intro</a>,
Previous:<a rel=previous href="#History">History</a>,
Up:<a rel=up href="#Top">Top</a>
<br>

<h1>Overview</h1>

<p>Pcb is a printed circuit board editor for the X11 window system. 
Pcb includes many professional features such as:
<ul>
<li>Up to 8 copper layer designs
<li>RS-274-X (Gerber) output
<li>NC Drill output
<li>Centroid (X-Y) data output
<li>Postscript and Encapsulated Postscript output
<li>Autorouter
<li>Trace optimizer
<li>Rats nest
<li>Design Rule Checker (DRC)
<li>Connectivity verification
<li>Pcb is Free Software
<li>Can interoperate with free schematic capture tools such as gEDA and
  xcircuit
</ul>

<p><hr>
Node:<a name="Intro">Intro</a>,
Next:<a rel=next href="#Getting%20Started">Getting Started</a>,
Previous:<a rel=previous href="#Overview">Overview</a>,
Up:<a rel=up href="#Top">Top</a>
<br>

<h1>Introduction</h1>

<p>Each layout consists of several, mostly independent, objects. This chapter
gives an overview of the object types and their relationship to each other. 
For a complete description of how to use <code>Pcb</code>, refer to
<a href="#Getting%20Started">Getting Started</a>. 
The layout is generated on-screen on a grid that can have its origin
at any desired location. 
The X coordinate increases to the right, Y increases down to the bottom. 
All distances and sizes in <code>Pcb</code> are measured in mils (0.001 inch). 
One unit on the coordinate display is one mil in distance on the board. 
The grid may be set on a metric pitch, but is only correct to within
the nearest +/- 1 mil. 
The sections in this chapter are sorted by the
order of appearance of the objects within a layout file.

<ul>
<li><a href="#Symbol%20Objects">Symbol Objects</a>:          Information about fonts and symbols. 
<li><a href="#Via%20Objects">Via Objects</a>:             Vias and pins connect layers. 
<li><a href="#Element%20Objects">Element Objects</a>:         Element, the basic type of circuits. 
<li><a href="#Layer%20Objects">Layer Objects</a>:           A <code>container</code> for lines, text... 
<li><a href="#Line%20Objects">Line Objects</a>:            Tracks on the board
<li><a href="#Arc%20Objects">Arc Objects</a>:             Curved tracks
<li><a href="#Polygon%20Objects">Polygon Objects</a>:         Planes and such
<li><a href="#Text%20Objects">Text Objects</a>:            Objects to add symbols to your board. 
<li><a href="#Net%20Objects">Net Objects</a>:             Describes the desired connections on the board. 
</ul>

<p><hr>
Node:<a name="Symbol%20Objects">Symbol Objects</a>,
Next:<a rel=next href="#Via%20Objects">Via Objects</a>,
Up:<a rel=up href="#Intro">Intro</a>
<br>

<h2>Symbols</h2>

<p>The top object is the layout itself. It uses a set of symbols
that resides at the first logical level. Each symbol is uniquely identified
by a seven bit <code>ASCII</code> code. All layout objects share the same set of
symbols. These symbols are used to form text objects on the silkscreen
and copper layers.  Undefined symbols are drawn as filled rectangles.

<p>Every font file is preprocessed by a user-defined command when it is loaded. 
For details see <code>fontCommand</code>, <a href="#Resources">Resources</a>.

<p><hr>
Node:<a name="Via%20Objects">Via Objects</a>,
Next:<a rel=next href="#Element%20Objects">Element Objects</a>,
Previous:<a rel=previous href="#Symbol%20Objects">Symbol Objects</a>,
Up:<a rel=up href="#Intro">Intro</a>
<br>

<h2>Vias</h2>

<p>Vias provide through-hole connectivity across all layers. 
While vias look a lot like element pins, don't use vias
for adding elements to the layout, even if that seems
easier than creating a new element. The default solder-mask
will cover over vias, so you won't be able to solder to them. 
Of course, you can change this so that vias also have
solder-mask cut-outs, but it is not the default. 
Vias are also useful for defining arbitrary drill points such as
those used for mounting a board. Vias used in this way have
a special flag set so that they have no annular copper ring,
and also appear in the unplated drill file. <em>Ctrl-H</em> key over
a via switches it between being a pure-mounting hole and a regular via. 
You can assign a name to a via, which is useful during the creation
of new element definitions. 
Each via exists on all copper layers. (<em>i.e.</em>
blind and buried vias are not supported)

<p><hr>
Node:<a name="Element%20Objects">Element Objects</a>,
Next:<a rel=next href="#Layer%20Objects">Layer Objects</a>,
Previous:<a rel=previous href="#Via%20Objects">Via Objects</a>,
Up:<a rel=up href="#Intro">Intro</a>
<br>

<h2>Elements</h2>

<p>Elements represent the components on a board. 
Elements are loaded from <code>ASCII</code> coded files in a
similar manner to the layout file itself, or from the
library selector window. 
An element is composed of lines and arcs on the silk-screen
layer (used to define the package outline), pins
(or pads for SMD) and three labels that define the
description, the element's layout-name (which also
appears on the silk-screen layer) and its value. You
can choose which of the names are displayed on the screen
with the <b>Screen</b> menu; however, the silk screen in
the printout will always show the layout-name. 
Element pins are contained on the first logical level
and so reside on all layers, but the pads of surface-mount
elements reside on only the component or solder
layers. An element can have a mixture of pins, pads
(on one or both sides), and mounting holes.

<p>A mark is used to position the element with
respect to the cross hair during pasting. 
The mark will lie on a grid point when the element
is positioned.  The mark is drawn as a small diamond
shape, but is only visible when <em>both</em> the <code>silk</code>
and <code>pins/pads</code> layers are visible. 
All parts of an element are treated as one unit, except for
the name. 
It is not possible to delete a single pin or move
only part of an element on the layout. 
You can resize separate pieces of an element,
but doing so is usually a bad idea. You can move/rotate
the element name independtly of the element it belongs
to. When you move an element name, a line is draw from
the cursor to the element mark so it is easy to tell
which element the name belongs to.

<p>Each pin and pad has two string identifiers, one is the
"name" which is a functional description of the pin
(<em>e.g.</em> "clock in") and the other is the "number" of the
pin which is used to identify it in a netlist. The "number"
is usually an interger, but it can be any string. You
can edit the "name" of each pin of an element, but the
"number" is imbedded in the element definition and is
determined when the new element is first created. 
Pads are similar to lines on a layer but they must be oriented
either vertically or horizontally. 
Pads can have either rounded or square ends. Pins
can be round, square, or octagonal.

<p>Elements are supported by several special layers: <code>silk</code>, <code>pins/pads</code> and
<code>far-side</code>.  The <code>silk</code> layer shows the package outline and
also holds legend text and element names. The <code>pins/pads</code> layer is used to toggle
whether the element's pins and pads are displayed. The <code>far-side</code> layer controls visibility
of objects (silkscreen and pads) that are on the far (<em>i.e.</em> not currently viewed) side
of the board.

<p>Every element file is preprocessed by a user-defined command when the file is read. 
For details see <code>elementCommand</code>, <a href="#Resources">Resources</a>. <code>m4</code>, the default
value of <code>elementCommand</code>, allows you to create libraries for
package definitions that are shared by all elements. 
The old element libraries distributed with <code>Pcb</code> expect <code>m4</code> or an
equivalent to be the <em>elementCommand</em>. The new library scheme simply has
each element stored in a self-contained file, so there is no need to learn
<code>m4</code> to add to the libraries.

<p><code>Pcb</code> can create a list of
all connections from one (or all) elements to the others or a list of
unconnected pins. 
It can also verify the layout connections against a netlist file. 
The element's <code>layout-name</code> is the name used to identify the element
in a netlist file (see <a href="#Netlist%20File">Netlist File</a>).

<p>The old libraries, or very old (pre-1.6) layout files may have
incorrect pin numbering since there was no concept of pin numbers
when they were created. <code>Pcb</code> uses the order of appearance of
the pin definitions in the layout or library file if it uses the
old format, but there is no guarantee that it will be correct for
these old objects.

<p><b>Be aware that a few of the old library parts may still be incorrectly
implemented regarding pin-numbering.</b>  All of the DIL (Dual-
Inline-Pins) parts are correct and most of the others are too,
but you should verify the pin numbering
of any non-DIL part before using an old library part. 
(use the <code>generate object report</code> in the <b>Info</b> menu
to see what <code>Pcb</code> thinks a pin's number is)
All of the old
library names begin with a ~, so you can easily identify them. 
The old libraries also <em>may</em> contain other sorts of errors,
including incorrect pin spacing, silkscreen overlaping solder areas, etc. 
<b>Check carefully any element in the old library before using it!</b>
As the new library grows, the old library will be paired down to
at least remove all of the elements with errors, but this will
take time.

<p>You can make your own element definitions graphically now. 
Simply draw vias for the pins, lines on the solder and/or
component layers for surface-mount pads (they must be either horizontal
or vertical),
and lines and arcs on the silkscreen layer for the silkscreen
outline. You should <em>name</em> (<em>N</em> key) each via and copper line with the pin <em>number</em>. 
Once you are happy with the geometry, select everything that is to become part of
the element, then choose <code>convert selection to element</code> from the <b>Select</b> menu. 
Afterwards you can make pin (or pad) one
square if you like, and give the element its various names. You can also give
the pins and pads their functional names. Note that the
element mark corresponds to the position you click after choosing the
conversion from the menu, so decide where the mark goes and make
sure it falls on a grid point before you request the conversion. 
If the vias/lines are not named, then the pin numbering will correspond to the
order in which they were placed.

<p>When you create a new element, remember that silkscreen lines
should <em>never</em> overlap the copper part of the
pins or pads, as this can interfere with soldering. The silkscreen
should identify the maximum extent of the element package so it
is easy to see how close elements can be placed together.

<p>If you want to make an element similar to an existing one, you can
break an element into constituent pieces from the <b>Buffer</b> menu. 
Paste the pieces to the layout, make the necessary changes, then
convert it back into an element. If the pin numbers haven't changed,
there is no need to name each via/line as they are pre-named when
the element was broken apart. When you create a new element, you
can save it to a file in order to have easy access to it the next
time you run <code>Pcb</code>.

<p><hr>
Node:<a name="Layer%20Objects">Layer Objects</a>,
Next:<a rel=next href="#Line%20Objects">Line Objects</a>,
Previous:<a rel=previous href="#Element%20Objects">Element Objects</a>,
Up:<a rel=up href="#Intro">Intro</a>
<br>

<h2>Layers</h2>

<p>Every layout consists of several layers that can be used independently
or treated as a group. 
Layer groups can be used to logically separate (and color-code)
different traces (<em>e.g.</em> power and signal); however, all
layers within a group reside on the same physical
copper layer of a board, so using different layers within the same
group won't provide electrical separation where they touch or overlap. 
For details, see <code>layerGroups</code>, <a href="#Resources">Resources</a>. 
Each layer is drawn in a color defined in the resource file
and identified by a name that you can change (for details
see <code>layerColor</code>, <a href="#Resources">Resources</a>.) 
Layers are really just containers for line, arc, polygon, and text objects.  The
component and solder layers contain SMD elements as well, but the
file structure doesn't reflect that fact directly.

<p>Each layer group
represents a physical layer on the printed circuit board.  If you want to make
a four layer board, you'll need to have at least four layer groups. 
Connections between layer groups are established only through element pins and vias. 
The relationship between a specific layer and the board itself is configureable from
the <code>Edit layer groups</code> option in the <b>Settings</b> menu. 
The layer groups corresponding to the physical layers: <em>component-side</em>
and <em>solder-side</em> are always defined and you must map at least one
logical layer to each, even if you plan to make a single-sided board. 
You are not obligated to put tracks on either of them. 
Surface mount elements always reside on either the component-side or the
solder-side layer group. When you paste an element from the buffer,
it will go onto whichever side of the board you are viewing. 
You can swap which side of the board you are viewing by pressing
the <em>Tab</em> key, or by selecting <code>view solder side</code> from the
<b>Screen</b> menu. 
The layer groups just have a name or number associated with them - where
they are sandwiched in the board is left for you to tell the
manufacturer.

<p>The silkscreen layer is special because there are actually two silkscreen
layers, one for the top (component) and one for the bottom (solder) side
of the board. Which silk layer you draw on is determined by the side of the
board that you are viewing. If you are viewing the component side, then
drawing on the silk layer draws to the component-side silk layer.

<p>The netlist layer is another special layer. It shows rat's-nest lines
(<em>i.e.</em> guides that show how the netlist expects the element to interconnect). 
If you make this the active layer, you can use the Line tool to add
entries into the netlist, or to delete connections from the netlist
window. Except for these two purposes, you should not
make the netlist layer the active layer. Usually there is no need to
do this because a separate schematic package should be used to create the
netlist. <code>Pcb</code> can automatically draw all of the rats from
the netlist. In some cases you may want to make a small change without
going to the trouble of modifying the schematic, which is why this
fascility is provided.

<p><hr>
Node:<a name="Line%20Objects">Line Objects</a>,
Next:<a rel=next href="#Arc%20Objects">Arc Objects</a>,
Previous:<a rel=previous href="#Layer%20Objects">Layer Objects</a>,
Up:<a rel=up href="#Intro">Intro</a>
<br>

<h2>Lines</h2>

<p>Lines are used to draw tracks on the pc board. 
When in the line mode, each <em>Btn1</em>
press establishes one end of a line. 
Once the second point is defined, the line is drawn
and a new line started where the first one ended. 
You can abondon the new starting point in favor
of another by pressing <em>Ctrl-Btn1</em>, or
<em>Btn3</em>, but don't use <em>Btn2</em>. 
The undo function (<em>U</em> key or <code>undo last operation</code>
from the <b>Edit</b> menu) will take you back
point by point if you use it while in the line mode. If you drag
the pointer out of the Layout area while drawing a line, the
display will auto-scroll (assuming sufficient zoom for scrolling). 
To stop auto-scroll, simply pass the pointer over the panner control.

<p>New lines can be restricted to 45 degree angles if desired. You can toggle this
restriction on and off while creating lines by pressing the <em>period</em> key. 
If the 45 degree restriction is turned on, then the <em>/</em> (forward slash) key
can be used to cylce through three different modes of 45 degree line creation. 
One mode just creates a single line forced to the nearest 45 degree vector.  The next
mode creates two lines from the start to end points such that the first line leaves the
start point at a 90 degree vector, and the second line enters the end point on a 45
degree vector. The last mode creates two lines such that the first line leaves the
start point on a 45 degree vector and arrives at the end point on a 90 degree vector. 
You can temporarily swap between the last two modes by holding the <em>Shift</em> key down.

<p>It is simple to edit a line object by breaking it into pieces (insert point mode),
moving an end point or the whole line (<em>Arrow tool</em>),
or changing the layer it resides on (<em>M</em> key moves the line under the pointer
to the active layer). 
In the case when two line segments meet at exactly the same
point you can delete the intermediate point, otherwise the delete tool removes an entire line. 
Feel free to experiment
since <code>Pcb</code> will allow you to undo and redo anything that materially affects your work. 
If you switch active layers in the midst of placing lines a via will automatically be
placed, when necessary, in order to continue the connection.

<p>If you draw a line inside a polygon, it will either plow through the
polygon creating a clearance, or touch the polygon. This behavior is
selectable in the <b>Settings</b> menu for new lines. To change the
behavior of an existing line, hit the <em>J</em> key with the cross hair
over the line. You can increase the size of the clearance with the
<em>K</em> key. <em>Shift-K</em> will decrease the clearance.

<p>Lines do not need to intersect the center of a pin, pad, via, or other
line for <code>Pcb</code> to understand that they make electrical connection. 
If the connection is too tenuous, running the design rule checker will report
that the connection may break if the line width shrinks slightly.

<p><hr>
Node:<a name="Arc%20Objects">Arc Objects</a>,
Next:<a rel=next href="#Polygon%20Objects">Polygon Objects</a>,
Previous:<a rel=previous href="#Line%20Objects">Line Objects</a>,
Up:<a rel=up href="#Intro">Intro</a>
<br>

<h2>Arcs</h2>

<p><code>Pcb</code> can handle arcs of any angular extent, but when you
create an arc with the Arc tool, it will
be a quarter circle (this means they always bend a right angle).  Arcs are very similar
to lines otherwise.  They are created on the active layer and have the same thickness
that new lines will have.  The various clicks for creating lines work pretty much the
same way for creating arcs. 
In order to make the arc curve in the desired direction, drag the mouse along
the tangent line from the starting position towards the end position. If the grid is
too coarse, it may not be possible to distinguish whether you've moved over then up,
or up then over, so if you can't seem to make the arc go in the direction you want, try pressing
the <em>Shift</em> key while drawing the arc. Decreasing the grid spacing may also help. 
Alternatively you can draw the wrong arc, then
rotate and move it where you want. Like the Line tool, after an arc is drawn a new
starting point is established at the end point.

<p>Whenever a starting point is established
by either the Line or Arc tools it will be retained if you switch directly between the
tools (e.g. <em>F2</em> key for Lines, <em>F8</em> key for Arcs. Arcs can either touch or
clear polygons just like lines do. Of course connection
searches, undo and all the other features you'd expect work with arcs too.

<p><hr>
Node:<a name="Polygon%20Objects">Polygon Objects</a>,
Next:<a rel=next href="#Text%20Objects">Text Objects</a>,
Previous:<a rel=previous href="#Arc%20Objects">Arc Objects</a>,
Up:<a rel=up href="#Intro">Intro</a>
<br>

<h2>Polygons</h2>

<p>Sometimes it's useful to fill large areas with solid copper. 
The way to do this is with polygons. 
Polygons can be created in either the polygon mode or the rectangle mode. 
In the polygon mode, you'll have to define each corner of the polygon
with a mouse click (<em>Btn1</em>). When the last point is clicked
exactly on top of the starting point, the polygon is finished. 
Since this can be hard to do, the <em>Shift-P</em> key will enter the
final point for you, closing the polygon. 
If the 45 degree angle restriction is turned on
and you try to close the polygon when it is not possible, you'll get a
warning instead. If you haven't finished entering a polygon, but want to
undo one (or more) of the points that you've already defined, use the
undo command (<em>U</em> key).

<p>With the rectangle tool, defining
the two diagonally opposite corners is sufficient, but of course the resulting
polygon is a rectangle. 
Like lines, a polygon can by edited by deleting, inserting and moving the points
that define it. Pins and vias <em>always</em> clear through polygons without
touching them when first positioned. You must add a thermal with the thermal
tool in order to connect pins and vias to polygons. Thermals can be added and removed by
clicking <em>Btn1</em> with the thermal tool over the pin or via. 
The thermal tool always
places a thermal to polygons on the active layer, so if the tool doesn't
seem to work, it's probably because the polygon you want to touch is not
on the active layer.

<p><code>Pcb</code> is capable of handling complex polygons, but
using a number of simpler ones improves performance of the connection tracing code. 
You also must be careful not to create polygons that touch or overlap themselves. 
The fabricated board may not look the way you expect if you violate this
principle. It is always ok to have two (or more) polygons touch or overlap
each other, but not for points within the same polygon to do so.

<p>The great advantage to this new polygon behavior is that simple or complex ground
and/or power planes can be easily made with polygons and seen on the screen. 
If you don't want this auto-clearance behavior, or you load a layout created by
an early version of <code>Pcb</code>, the old behavior
(shorts to all piercing pins and vias) is available.  A <code>ChangeSize</code>
operation (<em>S</em> key) toggles a polygon between the new and old polygon/pin
behavior.

<p><hr>
Node:<a name="Text%20Objects">Text Objects</a>,
Next:<a rel=next href="#Net%20Objects">Net Objects</a>,
Previous:<a rel=previous href="#Polygon%20Objects">Polygon Objects</a>,
Up:<a rel=up href="#Intro">Intro</a>
<br>

<h2>Text</h2>

<p>Text objects should be used to label a layout or to put additional
information on the board. Elements have their <code>layout-name</code> labels on the
silk-screen layer. If you are making a board without a silkscreen,
you can use copper text to label the elements, but you have to do
this manually.

<p>Text is always horizontal when first created, but the
rotate mode can align it along 0, 90, 180 and 270 degree angles. 
Text on the far side of the board will automatically appear mirror-imaged.

<p><em>Warning:</em> <b>TEXT OBJECTS ON A COPPER LAYER CREATE COPPER LINES BUT THEY ARE NOT SCANNED FOR
CONNECTIONS OR TESTED FOR CREATING SHORTS VS. THE NETLIST. NEITHER ARE TEXT OBJECTS TESTED AGAINST ANY DESIGN RULES</b>.

<p><hr>
Node:<a name="Net%20Objects">Net Objects</a>,
Previous:<a rel=previous href="#Text%20Objects">Text Objects</a>,
Up:<a rel=up href="#Intro">Intro</a>
<br>

<h2>Nets</h2>

<p>Layout files also contain the netlist that describes how the elements
are supposed to be interconnected. This list of connetions can be
loaded from a netlist file (see <a href="#Netlist%20File">Netlist File</a>), or
entered by drawing rat-lines as described
previously. Each net has a name and routing style associated with it. 
The net contains a list of all element <em>layout-name</em> names and
pin <em>numbers</em> that should
be connected to the net. Loading a netlist file will replace all
existing nets with the ones from the file. 
The <em>Netlist</em> window provides an easy way to
browse through the net list. You can display the rat's-nest by selecting
<code>optimize rats-nest</code> from the <b>Connects</b> menu. If you move or rotate elements,
the rat's-nest will automatically follow the movements, but they won't
necessarily show the shortest paths until you optimize them again.

<p><hr>
Node:<a name="Getting%20Started">Getting Started</a>,
Next:<a rel=next href="#User%20Commands">User Commands</a>,
Previous:<a rel=previous href="#Intro">Intro</a>,
Up:<a rel=up href="#Top">Top</a>
<br>

<h1>Getting Started</h1>

<p>The goal of this chapter is to give you enough information to learn how
<code>Pcb</code> works and how to develop your layouts to make the best use of <code>Pcb</code>'s
features. All event translations (<em>i.e.</em> the buttons and keys you
press) refer to the default application resource file shipped with <code>Pcb</code>. 
There is probably no need to change this unless your window
manager uses some of the button events itself; however, if you <em>want</em>
to customize the behavior of <code>Pcb</code> then changing the resource file
is usually the best way to do it.

<p>Get yourself a printout of this chapter and <em>User Commands</em>, if you
haven't already done so, and follow the examples.

<p>Start <code>Pcb</code> (the actual command will use all lower-case letters)
without any additional options. 
If you get the error message:

<pre>    can't find default font-symbol-file 'default_font'
</pre>
<br>then the font searchpath or filename in the application resource<br>
<p>file is wrong. Be sure that your <code>m4</code> program supports searchpaths. 
If not, get <code>GNU m4</code>. 
For other messages, see <a href="#problems">problems</a>. 
Another quick-start is provided by <code>pcbtest.sh</code> in the <code>src</code>
directory. If some features don't seem to work, try running <code>pcbtest.sh</code>,
if that works, then <code>Pcb</code> hasn't been installed properly.

<ul>
<li><a href="#Application%20Window">Application Window</a>:      The elements of the main window. 
<li><a href="#Log%20Window">Log Window</a>:              The optional logging window
<li><a href="#Library%20Window">Library Window</a>:          The circuit selection window
<li><a href="#Netlist%20Window">Netlist Window</a>:          The desired connections window
<li><a href="#Drawing%20and%20Removing">Drawing and Removing</a>: 
<li><a href="#Moving%20and%20Copying">Moving and Copying</a>: 
<li><a href="#Loading%20and%20Saving">Loading and Saving</a>: 
<li><a href="#Printing">Printing</a>:                Creating Gerber files or postscript files
<li><a href="#Arrow%20Tool">Arrow Tool</a>:              Selecting/Moving objects. 
<li><a href="#Rats%20Nest">Rats Nest</a>: 		   Helps you place and route tracks against a netlist. 
<li><a href="#Design%20Rule%20Checking">Design Rule Checking</a>:    Check for manufactureability
<li><a href="#Trace%20Optimizer">Trace Optimizer</a>:         Optimization of layouts
<li><a href="#Connection%20Lists">Connection Lists</a>:        How to get a list of all or some connections. 
</ul>

<p><hr>
Node:<a name="Application%20Window">Application Window</a>,
Next:<a rel=next href="#Log%20Window">Log Window</a>,
Up:<a rel=up href="#Getting%20Started">Getting Started</a>
<br>

<h2>The Application Window</h2>

<p>The main window consists of six areas:
the menu at the top, the panner control in the upper left corner, the layer
controls located below the panner, the tool buttons
located below the layer controls, the Layout area to the right of these, and the
status line at the bottom of the window.

<ul>
<li><a href="#Menu">Menu</a>: 
<li><a href="#Status-line%20and%20Input-field">Status-line and Input-field</a>:   What is the program configuration. 
<li><a href="#Panner%20Control">Panner Control</a>:                Used to pan the layout view when zoomed in. 
<li><a href="#Layer%20Controls">Layer Controls</a>:                Switch layers on/off; change current one. 
<li><a href="#Tool%20Selectors">Tool Selectors</a>:                Select a layout tool. 
<li><a href="#Layout%20Area">Layout Area</a>: 		         Where the layout is drawn. 
</ul>

<p><hr>
Node:<a name="Menu">Menu</a>,
Next:<a rel=next href="#Status-line%20and%20Input-field">Status-line and Input-field</a>,
Previous:<a rel=previous href="#Layout%20Area">Layout Area</a>,
Up:<a rel=up href="#Application%20Window">Application Window</a>
<br>

<h3>Menus</h3>

<p>The menus are located at the top of the Layout area. Most, but not all,
of their functions are also available from the keyboard. Similarly, some
functions are only achievable through the keyboard or command entry. 
Some menu entries such as <code>center layout</code> in the <b>Screen</b> menu require a certain cross hair position. 
In this case a promt message will popup at the bottom of the screen
with wording similar to the following:
<pre>move pointer to the appropriate screen position and press a button
</pre>
Any mouse button will do the job, whereas any key except the arrow (cursor) keys
will cancel the operation. If it seems like the menu hasn't done what you
expected, check to see if it is waiting for the position click. For details see <a href="#Actions">Actions</a>.

<p>Pressing <em>Btn3</em> in the Layout area also pops up a menu with many of the most common operations (except
when you're in the midst of drawing a line or arc). When
a choice in the <em>Btn3</em> popup menu needs a cross hair position, it uses the position
where the cross hair was when <em>Btn3</em> was pressed. For example, to get detailed
information on an object, place the cross hair over the object, press <em>Btn3</em>, then
choose <code>object report</code>.  If you pop up the <em>Btn3</em> menu but don't want to
take any of the actions, click on one of the headers in the menu.

<dl>

<br><dt><b>File</b>
<dd>This menu offers a choice of loading, saving and printing data, saving
connection information to a file or quitting the application. Most
of the entries in the <b>File</b> menu are self explanatory. 
Selecting
<code>print layout</code> pops up a printer control dialog. 
A selection of several device drivers is available from the printer control
dialog. Presently <em>PostScript</em>, <em>encapsulated PostScript</em>,
and <em>GerberX</em> are supported. The <em>GerberX</em> driver produces
all of the files necessary to have the board professionaly manufactured. 
The connection saving features in the <b>File</b> menu produce outputs in an
arcane format that is not too useful. They do <em>not</em> produce netlist
files.

<br><dt><b>Edit</b>
<dd>The <b>Edit</b> menu provides the usual cut, copy, paste
which work on selections. To learn how to
create complex selections, see <a href="#Arrow%20Tool">Arrow Tool</a>. 
The <b>Edit</b> menu also
provides access to Undo and Redo of the last operation. These
can also be accomplished with the <em>U</em> key and <em>Shift-R</em>
key.  Finally, the <b>Edit</b> menu allows you to change the names
of: the layout, the active layer, or text objects on the layout.

<br><dt><b>Screen</b>
<dd>The <b>Screen</b> menu supports most functions related to
the whole Layout area. There are various entries to change the grid to some popular
values, the zoom factor, and which kind of element name is displayed. 
You can also re-align the grid origin and turn on and off the display
of the grid. 
Before changing the grid alignment, I recommend that you zoom in as close as
possible so that you're sure the grid
points appear exactly where you want them.

<p>The <b>Screen</b> menu also allows you to turn on and off the
visiblity of the solder-mask layer. When the solder-mask layer
is made visible it obscures most of the layout, so only turn
this on when you really want to know what the solder-mask will
look like. The solder-mask that you see belongs to the
side of the board you are viewing, which can be changed with
the <code>view solder side</code> option, also found in the <b>Screen</b> menu. 
When the solder-mask is displayed, the pin and pad clearance adjustments
(see <a href="#Line%20Objects">Line Objects</a>) alter the size of mask cut-outs.

<br><dt><b>Sizes</b>
<dd>The <b>Sizes</b> menu allows you to select a group of line thickness, via diameter, via drill
size, and clearance (keepaway) (collectively called a "routing style") to be coppied to the "active" sizes. 
You can also change the names given to the routing styles and adjust their values from
this menu.  The "active" sizes are also adjustable from this menu. 
The "active" sizes are shown in the status-line and control the initial size of new vias,
drilling holes, lines, clearances, text-objects and also the maximum dimensions of the
board layout.

<br><dt><b>Settings</b>
<dd>The <b>Settings</b> menu controls several operating configuration
parameters. The <code>edit layer groups</code> entry brings up a dialog
that allows you to change the way layers are grouped. Layer grouping
is described in <a href="#Layer%20Objects">Layer Objects</a>. The <code>all-direction lines</code>
entry controls
the clipping of lines to 45-degree angles. You can also control
whether moving individual objects causes the attached lines to
"rubber band" with the move or not from the <b>Settings</b> menu. Another
entry controls whether the starting clip angle for the two-line
mode (see <a href="#Line%20Objects">Line Objects</a>) alternates every other line. You can
also control whether element names must be unique from the <b>Settings</b>
menu.  When unique element names are enforced, copying a new element
will automatically create a unique <code>layout-name</code> name for it
provided that the name originally ended with a digit (<em>e.g.</em>
U7 or R6). The <b>Settings</b> menu allows you to control
whether the cross hair will snap to pins and pads even when they
are off-grid. Finally you can control whether new lines and
arcs touch or clear intersecting polygons from this menu.

<br><dt><b>Select</b>
<dd>This menu covers most of the operations that work with selected objects. 
You may either (un)select all visible objects on a layout or only the ones
which have been found by the last connection scan see
. 
You can delete all selected objects from this menu. 
Other entries in the <b>Select</b> menu change the sizes of selected objects. 
Note that a select action only affects those objects that are
selected <em>and</em> have their visibility turned on in the Layer Control
panel. The <b>Select</b> menu also provides a means for selecting objects
by name using unix regular expressions.

<br><dt><b>Buffer</b>
<dd>TFrom the <b>Buffer</b> menu you may select one out of five
buffers to use, rotate or clear its contents or save the buffer contents
to a file. You can also use the <code>break buffer element to pieces</code> entry
to de-compose an element into pieces for editing. 
Note: only objects with visibility turned on are pasted to the layout. If
you have something in a buffer, then change which side of the board you
are viewing, the contents of the buffer will automatically be mirrored
for pasting on the side you are viewing. It is not necessary to clear
a buffer before cutting or copying something into it - it will automatically
be cleared first.

<br><dt><b>Connects</b>
<dd>The entries available through the <b>Connects</b> menu allow you to find
connections from objects and to manipulate these. 
You can also optimize or erase rat's nests from this menu. Finally,
the <code>auto-route all rats</code> entry allows you to auto-route
all connections show by the rat's nest. The auto-router will use
any visible copper layer for routing, so turn off the visibility of any
layers you don't want it to use. The auto-router will automatically
understand and avoid any traces that are already on the board, but
it is not restricted to the grid. Finally,
the auto-router routes using the active sizes (except for nets that
have a route-style defined). <code>Pcb</code> always knows which tracks
were routed by the auto-router, and you can selectively remove them
without fear of changing tracks that you have manually routed
with the <code>rip-up all auto-routed tracks</code> entry in the <b>Connects</b>
menu.  The <code>design rule checker</code> entry runs a check for copper
areas that are too close together, or connections that touch too
tenously for reliable production. The DRC stops when the first
problem is encountered so after fixing a problem be sure to
run it again until no problems are found.
<pre><em>Warning:</em> <b>COPPER TEXT IS IGNORED BY THE DRC CHECKER</b>.
</pre>

<br><dt><b>Info</b>
<dd>The <code>generate object report</code> entry from the <b>Info</b> menu
provides a way to get detailed information
about an object, such as its coordinates, dimensions, etc. 
You can also get a report summerizing all of the drills
used on the board with <code>generate drill summary</code>. Lastly,
you can get a list of all pins, pads and vias that were
found during a connection search.

<br><dt><b>Window</b>
<dd>The <b>Window</b> menu provides a way to bring each of <code>Pcb's</code>
windows to the front. The <em>Library</em> window is used to
bring elements from the library into the paste-buffer. The
<em>Message Log</em> window holds the various messages that
<code>Pcb</code> sends to the user. The <em>Netlist</em> window shows
the list of connections desired.

</dl>

<p>Now that you're familiar with the various menus, it's time
to try some things out. From the <b>File</b> menu choose
<code>load layout</code>, navigate to the tutorial folder, then
load the file <code>tut1.pcb</code>.

<p><hr>
Node:<a name="Status-line%20and%20Input-field">Status-line and Input-field</a>,
Next:<a rel=next href="#Panner%20Control">Panner Control</a>,
Previous:<a rel=previous href="#Menu">Menu</a>,
Up:<a rel=up href="#Application%20Window">Application Window</a>
<br>

<h3>The Status-line and Input-field</h3>

<p>The status-line is located at the bottom edge of the main window. 
During normal operation the status information is visible there. 
When a selected menu operation requires an additional button click, the
status-line is replaced by a message telling you to position the cursor
and click. 
When a text input is required, the status-line is replaced by the
Input-field which has a prompt for typing the input.

<p>The status-line shows, from left to right, the side of the board that you
are viewing (<em>Tab</em> key changes this), the current grid values,
if new lines are restricted to 45 degrees,
which type of 45 degree line mode is active, whether rubberband move and
rotate mode is on (R), and the zoom factor. 
This information is followed by the active line-width, via-size
and drilling hole, keepaway spacing, and text scaling. Last is the active buffer number and the
name of the layout. An asterisk appearing at the far left indicates that the
layout has been modified since the last save. 
Note that the name of the layout is not the same
thing as the filename of the layout. 
Change the grid factor to 1.0 mm from the <b>Screen</b> menu. Observe how the
status line shows the new grid setting. Except for the case of the metric
grid, all dimensions in the status line are in units of 0.001 inch (1 mil).

<p>The input-field pops up (temporarily replacing the status-line) whenever user input
is required. Two keys are bound to the input field: the <em>Escape</em> key
aborts the input, <em>Return</em> accepts it. Let's change the name of a component
on the board to see how the input-field works. Position the cross hair over
R5, and press the <em>N</em> key. The input field pops-up showing the name
for you to edit. Go ahead and change the name, then hit return. Notice the name
of the element changed. Now undo the change by pressing the <em>U</em> key. You can
position the cross hair over the name, or the element before pressing the
<em>N</em> key.

<p>Now select <code>realign grid</code> from the <b>Screen</b> menu. Notice that the
status line has been replaced with an instruction to position the cursor
where you want a grid point to fall. In this case, since the cross hair
can only fall on a grid point, you must move the tip of the finger cursor
to the place where you want a grid point to appear. Do not worry that
the cross hair is not coincident with the cursor. Click <em>Btn1</em> at
your chosen location. See how the grid has shifted, and the status line
has returned.

<p>The present cross hair position is displayed in the upper right corner of the window. 
Normally this position is an absolute coordinate, but you can anchor a marker at
the cross hair location by pressing <em>Ctrl-M</em> (try it now) and then the
display will read both the absolute cross hair position as well as the difference
between it and the marker. The numbers enclosed in &lt; &gt; are the X and Y distances
between the cross hair and the mark, while the numbers enclosed in parenthesis
are the distance and angle from the mark to the cross hair. The values displayed
are always in units of 0.001 inch (1 mil). 
Pressing <em>Ctrl-M</em> again turns the marker off.

<p><hr>
Node:<a name="Panner%20Control">Panner Control</a>,
Next:<a rel=next href="#Layer%20Controls">Layer Controls</a>,
Previous:<a rel=previous href="#Status-line%20and%20Input-field">Status-line and Input-field</a>,
Up:<a rel=up href="#Application%20Window">Application Window</a>
<br>

<h3>The Panner Control</h3>

<p>The panner control, located at the upper left side of the window, is used to
adjust what portion of the layout is seen in the Layout area. The outer
rectangle of the panner represents the whole layout (extended to have the
panner aspect ratio), while the inner control rectangle represents the
portion seen through the Layout area. Slowly drag this part around with
the mouse (<em>Btn1</em>) to see how it pans the layout. Release the panner
control, but leave the pointer within the outer most rectangle of the
control. Now hit a few keyboard arrow keys. Each arrow key moves the region
seen one-half window size in the arrow direction. If you want to see a
portion of the layout that is off the top of the screen, you need to
drag the panner up, or hit the up arrow key.

<p>Move the pointer back into the Layout area. 
Increase the zoom by hitting the <em>Z</em> key. See how the inner part of
the panner becomes smaller to reflect that you are viewing a smaller
part of the layout. Now zoom out by hitting <em>Shift-Z</em>. If you
hit the arrow key with the pointer in the Layout area, it moves
the pointer rather than scrolling the window. In general the keyboard
shortcuts depend on which region of <code>Pcb's</code> window the pointer
is over. For the most part, the key strokes in this manual refer to
the case when the pointer is in the Layout area. You can do fine
scrolling in the Layout area by dragging it directly with the
Panner tool. Press the <em>Escape</em> key to select the panner tool. 
Now drag in the layout area with <em>Btn1</em> down. You can scroll the drawing
window while the pointer is inside it with <em>Mod-Arrow</em>
keys.

<p>If you are moving or drawing an object and go beyond the drawing
window borders, the window will auto-scroll. If you want to stop
the auto-scrolling while the pointer is outside the Layout area,
simply pass the pointer briefly over the panner control area, or
a menu button.

<p>Another way to navigate around a layout is with <em>Shift-Btn3</em>. 
When pressed down, the layout will zoom so the whole extent of
objects is visible, and will return to the previous zoom when
you release the button, but will be centered at the cross hair
position where the button is released. You can do this while in
the middle of drawing an object. Try it now to center near
U7.

<p><hr>
Node:<a name="Layer%20Controls">Layer Controls</a>,
Next:<a rel=next href="#Tool%20Selectors">Tool Selectors</a>,
Previous:<a rel=previous href="#Panner%20Control">Panner Control</a>,
Up:<a rel=up href="#Application%20Window">Application Window</a>
<br>

<h3>The Layer Controls</h3>

<p>The layer control panel, located below the panner control, is used to turn on
and off the display of layer groups and to select the active drawing layer. 
If a layer hasn't been named, the label "<em>(unknown)</em>" is used as the default. 
If this happens, it probably means the application resources are not installed
properly.

<p>The upper buttons are used to switch layers on and off. Click
<em>&lt;Btn1&gt;</em> on one or more of them. Each click toggles the setting. 
If you turn off the currently active layer, another one that is visible
will become active. If there are no others visible, you will not be
able to turn off the active layer. 
When the layers are grouped, clicking on these buttons will toggle
the visibility of all layers in the same group. This is a good idea because
layers in the same group reside on the same physical layer of
the actual board. Notice that this example has 2 groups each having
3 layers, plus two other layers named <code>unused</code>. 
Use the <code>Edit layer groups</code> option in the <code>Settings</code> menu to
change the layer groupings. Note that changing the groupings can
radically alter the connectivity on the board. 
Grouping layers is only useful for helping you to color-code
signals in your layout. Note that grouping layers actually reduces the number
of different physical layers available for your board, so to make an eight
layer board, you cannot group any layers.

<p>The <em>far side</em> button turns on and off the visibility of elements
(including SMD pads) on the opposite (to the side you're viewing)
board side, as well as silk screening on that side. It does not
hide the x-ray view of the other copper layers, these must be turned off
separately if desired.  Use the <em>tab</em> key to view the entire board from the other
side.  To see a view of what the back side of the board will actually look like,
make the solder layer the active layer then press <em>tab</em> until the status
line says "solder" on the right, then turn off the visibility of all layers
except solder, pins/pads, vias, and silk. Now turn them all back on.

<p>The lowest button, named <em>active</em>, is used to change the active
drawing layer. Pressing <em>&lt;Btn1&gt;</em> on it pops up a menu to select which
layer should be active. 
Each entry is labeled with the layer's name and drawn in its color. 
The active layer is automatically made visible. The active layer is
always drawn on top of the other layers, so the ordering of layers
on the screen does not generally reflect the ordering of the manufactured
board. Only the solder, component, silkscreen, and solder-mask layers
are always drawn in their physical order. Bringing the active layer
to the top makes it easier to select and change objects on the active layer. 
Try changing the active layer's name to <em>ABC</em> by selecting
<code>edit name of active layer</code> from the <code>Edit</code> menu. 
Changing the active layer can also be done by pressing keys
<em>1..MAX_LAYER</em>.

<p>Turn off the visibility of the component layer. 
Now make the component layer the active layer. Notice that it
automatically became visible. Try setting a few
other layers as the active layer. You should also experiment
with turning on and off each of the layers to see what happens.

<p>The netlist layer is a special layer for adding connections to
the netlist by drawing rat lines. This is not the recommended
way to add to the netlist, but occasionally may be convenient. 
To learn how to use the netlist layer see <a href="#Net%20Objects">Net Objects</a>.

<p><hr>
Node:<a name="Tool%20Selectors">Tool Selectors</a>,
Next:<a rel=next href="#Layout%20Area">Layout Area</a>,
Previous:<a rel=previous href="#Layer%20Controls">Layer Controls</a>,
Up:<a rel=up href="#Application%20Window">Application Window</a>
<br>

<h3>The Tool Selectors</h3>

<p>The tool selector buttons reside below the layer controls. 
They are used to select which layout tool to use in the drawing
area. Each tool performs its function when <em>Btn1</em> is pressed. 
Every tool gives the cursor a unique shape that identifies it. 
The tool selector buttons themselves are icons that illustrate their function. 
Each layout tool can also be selected from the keyboard:
<pre>    <em>Escape</em> key   Panner tool
    <em>F1</em> key       Via tool
    <em>F2</em> key       Line tool
    <em>F3</em> key       Arc tool
    <em>F4</em> key       Text tool
    <em>F5</em> key       Rectangle tool
    <em>F6</em> key       Polygon tool
    <em>F7</em> key       Buffer tool
    <em>F8</em> key       Delete tool
    <em>F9</em> key       Rotate tool
    <em>Insert</em> key   Insert-point tool
    <em>F10</em> key      Thermal tool
    <em>F11</em> key      Arrow tool
    <em>F12</em> key      Lock tool
</pre>

<p>Some of the tools are very simple, such as the Via tool.  Clicking
<em>Btn1</em> with the Via tool creates a via at the cross hair position. 
The via will have the diameter and drill sizes that are active,
as shown in the status line. 
The Buffer tool is similar.  With it, <em>&lt;Btn1&gt;</em> copies
the contents of the active buffer to the layout, but only
those parts that reside on visible layers are copied. 
The Rotate tool allows you to rotate elements, arcs, and text objects
90 degrees counter-clockwise with each click. Holding the <em>Shift</em>
key down changes the Rotate tool to clockwise operation. 
Anything including groups of objects
can be rotated inside a buffer using the rotate buffer menu option.

<p>The Line tool is explained in detail in <a href="#Line%20Objects">Line Objects</a>. Go read
that section if you haven't already. 
Activate the Line tool. Set the active layer to the solder layer. 
Try drawing some lines. Use the <em>U</em> key to undo some of the
lines you just created. Zoom in a bit closer with the <em>Z</em> key. 
Draw some more lines. Be sure to draw some separate lines by starting
a new anchor point with <em>Ctrl-Btn1</em>. Change the <code>crosshair snaps to pin/pads</code>
behavior in the <b>Settings</b> menu. Now draw a line. Notice that
the new line points must now always be on a grid point. It might not
be able to reach some pins or pads with this setting. Increase the active line thickness
by pressing the <em>L</em> key. Note that the status line updates
to reflect the new active line thickness. Now draw another line. Before completing the
next line, make the component layer active by pressing the <em>4</em> key. 
Now finish the line. Notice that a via was automatically placed where
you switched layers. <code>Pcb</code> does not do any checks to make sure that
the via could safely be placed there. Neither does it interfere with
your desire to place lines haphazardly. It is up to you to place
things properly when doing manual routing with the Line tool.

<p>The Arc tool is explained in detail in <a href="#Arc%20Objects">Arc Objects</a>. Its
use is very similar to the Line tool.

<p>The Rectangle tool, Polygon tool and Thermal tool are explained in detail in
<a href="#Polygon%20Objects">Polygon Objects</a>. Go read that section. 
Remember that the Thermal tool will only create and destroy thermals
to polygons on the active layer. Use the Rectangle tool to make a
small copper plane on the component layer. Now place a via in the
middle of the plane. Notice that it does not touch the plane, and
they are not electrically connected. Use the Thermal tool to make
the via connect to the plane. Thermals allow the via or pin to
be heated by a soldering iron without having to heat the entire
plane. If solid connections were made to the plane, it could be
nearly impossible to solder. Click on the via again with the
Thermal tool to remove the connection to the plane.

<p>The Insert-point tool is an editing tool that allows you to add
points into lines and polygons.  The
Insert-point tool enforces the 45 degree line
rule.  You can force only the shorter line segment to 45
degrees by holding the <em>Shift</em> key down while inserting the point. 
Try adding a point into one of the lines you created. Since line
clipping is turned on, you may need to move the cross hair quite far
from the point where you first clicked on the line. Turn off the
line clipping by selecting <code>all-direction lines</code> from the
<b>Settings</b> menu (or hit
the <em>Period</em> key). Now you can place an inserted point anywhere. 
Try adding a point to the rectangle you made earlier. Start by clicking
somewhere along an edge of the rectangle, then move the pointer to
a new location and click again.

<p>The delete-mode deletes the object beneath the cursor with each
<em>Btn1</em> click. 
If you click at an end-point that two lines have in common, it will replace the two lines with a single line
spanning the two remaining points.  This can be used to delete an "inserted"
point in a line, restoring the previous line.  Now delete one of the original corner
points of the polygon you were just playing with. To do this, place the cross hair over the
corner and click on it with the Delete tool. You could also use the <em>Backspace</em> key
if some other tool is active. Try deleting some of
the lines and intermediate points that you created earlier. Use undo
repeatedly to undo all the changes that you've made. Use redo
a few times to see what happens. Now add a new line. Notice that
you can no longer use redo since the layout has changed since
the last undo happened. The undo/redo tree is always pruned in this
way (<em>i.e.</em> it has a root, but no branches).

<p>The Arrow tool is so important, it has its own section: <a href="#Arrow%20Tool">Arrow Tool</a>. 
Go read it now.

<p>The Lock tool allows you to lock objects on the layout. When an object
is locked, it can't be selected, moved, rotated, or resized. This is
useful for very large objects like ground planes, or board-outlines that
are definied as an element. With such large objects, nearly anywhere you
click with the Arrow tool will be on the large object, so it could be
hard to draw box selections. If you lock an object, the Arrow tool will
behave as if it didn't exist.  You cannot unlock an object with undo. 
You must click on it again with the Lock tool. If an object is locked,
previous changes to it cannot be undone either. When you lock
an object, a report message about it is popped up and will always tell
you what object it is, and that it is locked if you just locked it. 
Other than noticing your inability to manipulate something, the only
way to tell an object is locked is with a report from the <b>Info</b>
menu. Use the Lock tool sparingly.

<p><hr>
Node:<a name="Layout%20Area">Layout Area</a>,
Next:<a rel=next href="#Menu">Menu</a>,
Previous:<a rel=previous href="#Tool%20Selectors">Tool Selectors</a>,
Up:<a rel=up href="#Application%20Window">Application Window</a>
<br>

<h3>Layout Area</h3>

<p>The layout area is where you see the layout. The cursor shape depends
on the active tool when the pointer is moved into the layout area. 
A cross hair follows the X11 pointer with respect to the grid setting. 
Select a new grid from the <em>Screen</em> menu. 
The new value is updated in the status line. 
A different way to change the grid is
<em>Shift&lt;Key&gt;g</em> to decrease or <em>&lt;Key&gt;g</em> to increase
it, but this only works for English (integer mil) grids. 
The grid setting is saved along with the data when you save a pcb layout. 
For homemade layouts a value around 50 is a good setting. 
The cursor can also be moved in the layout area with the cursor (arrow) keys or, for larger
distances, by pressing the <em>Shift</em> modifier together with a cursor key.

<p><hr>
Node:<a name="Log%20Window">Log Window</a>,
Next:<a rel=next href="#Library%20Window">Library Window</a>,
Previous:<a rel=previous href="#Application%20Window">Application Window</a>,
Up:<a rel=up href="#Getting%20Started">Getting Started</a>
<br>

<h2>Log Window</h2>

<p>This optional window is used to display all kind of messages including
the ones written to <em>stderr</em> by external commands. The main advantage
of using it is
that its contents are saved in a scrolling list until the
program exits. Disabling this feature by setting the resource
<em>useLogWindow</em> to <em>false</em> will generate popup windows to display
messages. The <em>stderr</em> of external commands will appear on <code>Pcb</code>s
<em>stderr</em> which normally is the parent shell. I suggest you iconify
the log window after startup for example by setting <em>*log.iconic</em> to
<em>true</em> in the resource file. If <em>raiseLogWindow</em> is set <em>true</em>,
the window will deiconify and raise itself whenever new messages are to be
displayed.

<p><hr>
Node:<a name="Library%20Window">Library Window</a>,
Next:<a rel=next href="#Netlist%20Window">Netlist Window</a>,
Previous:<a rel=previous href="#Log%20Window">Log Window</a>,
Up:<a rel=up href="#Getting%20Started">Getting Started</a>
<br>

<h2>Library Window</h2>

<p>The library window makes loading elements (or even partial layouts) easy. 
Just click the appropriate library from the list on the left. A list
of its elements then appears on the right. Select an element
from the list by clicking on its description. Selecting an element from the
library will also automatically copy the element into
the active buffer, then invoke the <em>Buffer</em> tool so
you can paste it to the layout. Elements in the old library should be
taken with a grain of salt (<em>i.e.</em> check them carefully before
using).  The old library names all begin with ~ so you can easily distinguish between
the old and new libraries.  All of the elements in the new library
should  be thoroughly vetted, so you
can use them with confidence. The new libraries are stored simply
as directories full of element files, so making additions to the
new library is easy since there is no need to learn <code>m4</code>. 
For details on the old libraries,
check-out <a href="#Library%20File">Library File</a> and <a href="#Library%20Contents%20File">Library Contents File</a>. For
details on the format of an element file used for the new libraries,
see <a href="#Element%20File">Element File</a>.

<p><hr>
Node:<a name="Netlist%20Window">Netlist Window</a>,
Next:<a rel=next href="#Drawing%20and%20Removing">Drawing and Removing</a>,
Previous:<a rel=previous href="#Library%20Window">Library Window</a>,
Up:<a rel=up href="#Getting%20Started">Getting Started</a>
<br>

<h2>Netlist Window</h2>

<p>The netlist window is very similar to the library window. On the left
is a list of all of the nets, on the right is the list of connections
belonging to the chosen net. The chosen net is highlighted in the
list and also shown on the second line of the window in red. If the
net name has a star to the left of it then it is "disabled". A disabled
net is treated as if it were not in the net list. This is useful, for
example, if you plan to use a ground plane and don't want the ground
net showing up in the rat's nest. You can enable/disable individual
nets by double-clicking the net name. If you want to enable or disable
all nets at once, there are two buttons at the top of the netlist
window for this purpose.

<p>The button labeled <code>Sel Net On Layout</code>
can be used to select (on the layout) everything that is connected
(or is supposed to be connected) to the net. If you click on a
connection in the connection list, it will select/deselect
the corresponding pin or pad in the layout and also center the layout
window where it is located. If you "Find" (<code>lookup connection
to object</code> in the <b>Connects</b> menu [also <em>F</em> key]), a pin
or pad it will also choose the net and connection in the netlist window
if it exists in the netlist.

<p>If no netlist exists for the layout, then the netlist window does not
appear. You can load a netlist from a file from the <b>File</b> menu. The
format for netlist files is described in <a href="#Netlist%20File">Netlist File</a>.

<p><hr>
Node:<a name="Drawing%20and%20Removing">Drawing and Removing</a>,
Next:<a rel=next href="#Moving%20and%20Copying">Moving and Copying</a>,
Previous:<a rel=previous href="#Netlist%20Window">Netlist Window</a>,
Up:<a rel=up href="#Getting%20Started">Getting Started</a>
<br>

<h2>Drawing and Removing Basic Objects</h2>

<p>hace begging gutting here, and do a real-world tutorial example.

<p>There are several ways of creating new objects: you can draw them yourself,
you can copy an existing object (or selection), or you can load an element from a file or
from the Library window. Each type of object has a particular tool for creating it.

<p>The active tool can be selected from the tool selectors in the bottom
left corner or by one of the function keys listed earlier in this chapter. 
Each <em>&lt;Btn1&gt;</em> press with the tool tells the application to create
or change the appropriate object or at least take
the first step to do so. Each tools causes the cursor to take
on a unique shape and also causes the cooresponding
tool selector button to be highlighted. You can use either cue
to see which tool is active.

<p>Insert mode provides the capability of inserting new points into existing
polygons or lines. The 45 degree line clipping is now enforced when selected. 
Press and hold the shift key while positioning the new point to only clip
the line segment to the nearer of the two existing points to 45 degrees. 
You can also toggle the 45-degree clipping in the middle of a point
insertion by pressing the <em>&lt;Key&gt;.</em>
If the shift key is not depressed and the 45 degree line clipping mode
is on, both new line segments must be on 45 degree angles - greatly
restricting where the new point may be placed. In some cases this can cause
confusion as to whether an insertion has been started since the two new
lines may be forced to lie parallel on top of the original line until the
pointer is moved far from the end points.

<p>Removing objects, changing their size or moving them only applies to objects
that are visible when the command is executed.

<ul>
<li><a href="#Common">Common</a>:            Keystrokes common to some objects. 
<li><a href="#Lines">Lines</a>: 
<li><a href="#Arcs">Arcs</a>: 
<li><a href="#Polygons">Polygons</a>:          Drawing polygons and rectangles. 
<li><a href="#Text">Text</a>: 
<li><a href="#Vias">Vias</a>: 
<li><a href="#Elements">Elements</a>: 
<li><a href="#Pastebuffer">Pastebuffer</a>:       A multi-purpose buffer. 
</ul>

<p><hr>
Node:<a name="Common">Common</a>,
Next:<a rel=next href="#Lines">Lines</a>,
Up:<a rel=up href="#Drawing%20and%20Removing">Drawing and Removing</a>
<br>

<p>There are several keystrokes and button events refering to an <em>object</em>
without identifying its type. Here's a list of them:

<p><em>&lt;Btn1&gt;</em> creates (or deletes)  an object depending on the
current mode.

<p><em>&lt;Key&gt;BackSpace</em> or <em>&lt;Key&gt;Delete</em> removes the visible
object at the cursor location. When more than one object exists at the
location, the order of removal is: via, line, text, polygon and
element. The drawn layer order also affects the search - whatever is
top - most (except elements) is affected before lower items.  Basically
all this means that what is removed is probably just what you expect. 
If for some reason it isn't, undo and try again. 
Only one object is removed for each keystroke. If two or more
of the same type match, the newest one is removed.

<p>Use <em>&lt;Key&gt;s</em> and <em>Shift&lt;Key&gt;s</em> to change the size (width)
of lines, arcs, text objects, pins, pads and vias, or to toggle the style
of polygons (whether pins and vias automatically have clearances).

<p><em>&lt;Key&gt;n</em> changes the name of pins, pads, vias, the
string of a text object, or the currently displayed label of an element.

<p><em>&lt;Key&gt;m</em> moves the line, arc, or polygon under the cross hair to the
active layer if it wasn't on that layer already.

<p><em>&lt;Key&gt;u</em> (undo) recovers from an unlimited number of operations
such as creating, removing, moving, copying, selecting etc. It works like
you'd expect even if you're in the midst of creating something.

<p><em>Shift&lt;Key&gt;r</em> restores the last undone operation provided no other
changes have been made since the undo was performed.

<p><em>&lt;Key&gt;tab</em> changes the board side you are viewing.

<p>For a complete list of keystrokes and button events see <a href="#Translations">Translations</a>.

<p><hr>
Node:<a name="Lines">Lines</a>,
Next:<a rel=next href="#Arcs">Arcs</a>,
Previous:<a rel=previous href="#Common">Common</a>,
Up:<a rel=up href="#Drawing%20and%20Removing">Drawing and Removing</a>
<br>

<h3>Lines</h3>

<p>To draw new lines you have to be in <em>line-mode</em>. Get there either by
selecting it from the <em>Tool palette</em> or by pressing <em>&lt;Key&gt;F2</em>. 
Each successive <em>notify</em> event creates a new line. The
adjustment to 45 degree lines is done automatically if it is selected from the
<em>Display</em> menu. You can toggle the 45 degree mode setting by
pressing the <em>&lt;Key&gt;.</em> (That is the period key). When 45 degree enforcement
is turned on there are three distinct modes of line creation: a single
line on the closest 45 degree vector towards the cross hair (but not necessarily
actually ending at the cross hair), two lines created such that the first leaves
the start point on a 90 degree vector and the second arrives at the cross hair
on a 45 degree vector, and finally two lines created such that the first leaves
the start point on a 45 degree vector and the second arrives at the cross hair
on a 90 degree vector.  These last two modes always connect all the way from
the start and end points, and all lines have angles in 45 degree multiples. 
The <em>&lt;Key&gt;/</em> cycles through the three modes.  The status line shows a
text icon to indicate which of the modes is active and the lines following
the cross hair motion show the outline of the line(s) that will actually be created. 
Press <em>&lt;Key&gt;Escape</em> to leave line-mode.

<p><em>&lt;Key&gt;l</em>, <em>Shift&lt;Key&gt;l</em> and the entries in the
<em>Sizes</em> menu change the initial width of new lines.  This width is also
displayed in the status line.

<p><hr>
Node:<a name="Arcs">Arcs</a>,
Next:<a rel=next href="#Polygons">Polygons</a>,
Previous:<a rel=previous href="#Lines">Lines</a>,
Up:<a rel=up href="#Drawing%20and%20Removing">Drawing and Removing</a>
<br>

<h3>Arcs</h3>

<p>An Arc is drawn  with the <em>arc-tool</em>. Get there either by selecting it
from the <em>Tool palette</em> or by pressing <em>&lt;Key&gt;F8</em>. Press <em>Btn1</em> to
define the starting point for the arc.  Drag the mouse towards the desired
end point along the path you want the arc to follow.  The outline of the arc that
will be created is shown on the screen as you move the mouse.  Arcs are always
forced to be 90 degrees and have symmetrical length and width ( i.e. they are
a quarter circle).  The next <em>Btn1</em> click creates the arc.  It will have
the same width as new lines (displayed in the status line) and appear on the
active layer. The arc leaves the starting point towards the cross hair along
the axis whose distance from the cross hair is largest.  Normally this means that
if you drag along the path you want the arc to follow, you'll get what you
want.  If the grid is set to the arc radius, then the two distances will be
equal and you won't be able to get all of the possible directions.  If this
is thwarting your desires, reduce the grid spacing (<em>!Shift&lt;Key&gt;G</em>) and
try again.

<p><hr>
Node:<a name="Polygons">Polygons</a>,
Next:<a rel=next href="#Text">Text</a>,
Previous:<a rel=previous href="#Arcs">Arcs</a>,
Up:<a rel=up href="#Drawing%20and%20Removing">Drawing and Removing</a>
<br>

<h3>Polygons and Rectangles</h3>

<p>A polygon is drawn by defining all of its segments as a series of
consecutive line segments. If the first point matches a new one and if
the number of points is greater than two, then the polygon is closed. 
Since matching up with the first point may be difficult, you may use
<em>Shift&lt;Key&gt;p</em> to close the polygon. The <em>Shift&lt;Key&gt;p</em> won't
work if clipping to 45 degree lines is selected
and the final segment cannot match this condition. 
I suggest you create simple convex polygons in order to avoid a strong
negative impact on the performance of the connection scanning routines. 
The <em>rectangle-mode</em> is just an easy way to generate rectangular polygons. 
<em>Polygon-mode</em> also is selected by <em>&lt;Key&gt;F6</em> whereas
<em>rectangle-mode</em> uses <em>&lt;Key&gt;F4</em>. 
Pressing a <em>&lt;Btn1&gt;</em> at two locations creates a rectangle by
defining two of its corners. 
<em>&lt;Key&gt;Insert</em> brings you to <em>insert-point-mode</em> which lets you
add additional points to an already existing polygon. 
Single points may be removed by moving the cross hair to them and selecting
one of the delete actions <em>(remove-mode, BackSpace, or Delete</em>. This only works
if the remaining polygon will still have three or more corners. 
Pressing <em>&lt;Key&gt;u</em>  or <em>&lt;Key&gt;p</em> while entering a new polygon
brings you back to the previous corner. Removing a point does not
force clipping to 45 degree angles (because it's not generally possible). 
Newly created polygons will not connect to pins or vias
that pierce it unless you create a thermal (using the thermal mode) to make
the connection. If the edge of a polygon gets too close to a pin or via that
lies outside of it, a warning will be issued and the pin will be given a
special color. Increasing the distance between them will remove the warning
color.

<p><hr>
Node:<a name="Text">Text</a>,
Next:<a rel=next href="#Vias">Vias</a>,
Previous:<a rel=previous href="#Polygons">Polygons</a>,
Up:<a rel=up href="#Drawing%20and%20Removing">Drawing and Removing</a>
<br>

<h3>Text</h3>

<p>Pressing <em>&lt;Key&gt;F5</em> or clicking one of the text selector buttons
changes to <em>text-mode</em>. 
Each successive notify event (<em>&lt;Btn1&gt;</em>)
pops up the input line at the bottom and queries for a string. 
Enter it and press <em>&lt;Key&gt;Return</em> to confirm or
<em>&lt;Key&gt;Escape</em> to abort. 
The text object is created with its upper left corner at the current pointer
location. 
The initial scaling is changed by <em>&lt;Key&gt;t</em> and
<em>Shift&lt;Key&gt;t</em> or from the <em>Sizes</em> menu.

<p>Now switch to <em>rotate-mode</em> and press
<em>&lt;Btn1&gt;</em> at the text-objects location. Text objects
on the solder side of the layout are automatically mirrored and
flipped so that they are seen correctly when viewing the solder-side.

<p>Use <em>&lt;Key&gt;n</em> to edit the string.

<p><b>TEXT OBJECTS ON COPPER LAYERS CREATE COPPER LINES BUT THEY ARE NOT SCANNED FOR
CONNECTIONS</b>. If they are moved to the silkscreen layer, they
no longer create copper.

<p><hr>
Node:<a name="Vias">Vias</a>,
Next:<a rel=next href="#Elements">Elements</a>,
Previous:<a rel=previous href="#Text">Text</a>,
Up:<a rel=up href="#Drawing%20and%20Removing">Drawing and Removing</a>
<br>

<h3>Vias</h3>

<p>The initial size of new vias may be changed by <em>&lt;Key&gt;v</em> and
<em>Shift&lt;Key&gt;v</em> or by selecting the appropriate entry from the
<em>Sizes</em> menu. <em>Mod1&lt;Key&gt;v</em> and <em>Mod1 Shift&lt;Key&gt;v</em> do
the same for the drilling hole of the via. 
The statusline is updated with the new values. 
Creating a via is similar to the other objects. Switch to <em>via-mode</em>
by using either the selector button or <em>&lt;Key&gt;F1</em> then press
<em>&lt;Key&gt;]</em> or <em>&lt;Btn1&gt;</em> to create one. 
<em>&lt;Key&gt;n</em> changes the name of a via. If you want to create a mounting
hole for your board, then you can place a via where you want the hole to
be then convert the via into a hole.  The conversion is done by pressing
<em>!Ctrl&lt;Key&gt;h</em> with the cross hair over the via.  Conceptually it is
still a via, but it has no copper annulus.  If you create such a hole in
the middle of two polygons on different layers, it will short the layers. 
Theoretically you could arrange for such a hole not to be plated, but a
metal screw inserted in the hole would still risk shorting the layers. 
A good rule is to realize that holes in the board really are vias between
the layers and so place them where they won't interfere with connectivity. 
You can convert a hole back into a normal via with the same keystroke used
to convery it in the first place.

<p><hr>
Node:<a name="Elements">Elements</a>,
Next:<a rel=next href="#Pastebuffer">Pastebuffer</a>,
Previous:<a rel=previous href="#Vias">Vias</a>,
Up:<a rel=up href="#Drawing%20and%20Removing">Drawing and Removing</a>
<br>

<h3>Elements</h3>

<p>Some of the functions related to elements only work if both the package
layer and the pin layer are switched on.

<p>Now that you're familiar with many of the basic commands, it is
time to put the first element on the layout. 
First of all, you have to load data into the paste buffer. 
There are four ways to do this:
<pre>   1) load the data from a library
   2) load the data from a file
   3) copy data from an already existing element
   4) convert objects in the buffer into an element
</pre>
We don't have any elements on the screen yet nor anything in the
buffer, so we use number one.

<p>Select <em>lsi</em> from the menu in the library window press
<em>&lt;Btn1&gt;</em> twice at the appropriate text-line to get
the MC68030 CPU. 
The data is loaded and the mode is switched to <em>pastebuffer-mode</em>. 
Each notify event now creates one of these beasts. Leave the mode
by selecting a different one or by <em>&lt;Key&gt;Escape</em> which resets
all modes.. 
The cross hair is located at the <em>mark</em> position as defined by
the data file. Rotating the buffer contents is done by selecting
the <em>rotate</em> entry of the <em>Buffer</em> menu or by pressing
<em>Shift&lt;Key&gt;F3</em>. The contents of the buffer
are valid until new data is loaded into it either by a cut-to-buffer
operation, copy-to-buffer operation or by loading a new data file. 
There are 5 buffers
available  (possibly more or less if changed at compile time
with the <code>MAX_BUFFER</code> variable in <code>globalconfig.h</code>). 
Switching between them is done by selecting a menu entry or
by <em>Shift&lt;Key&gt;1..MAX_BUFFER</em>. 
Each of the two board sides has its own buffers.

<p>The release includes all data files for the circuits that are used
by the demo layout. The elements in the LED example are not found in the library,
but you can lift them from the example itself if you want. 
If you have problems with the color of the cross hair, change the resource
<em>cross hairColor</em> setting to a different one.

<p>Now load a second circuit, the MC68882 FPU for example. 
Create the circuit as explained above. You now have two different unnamed
elements. Unnamed means that the layout-name of the element
hasn't been set yet. Selecting <em>description</em> from the <em>Display</em>
menu displays the description string of the two circuits which
are CPU and FPU. The values of the circuits are set to MC68030 and MC68882. 
Each of the names of an element may be changed
by <em>&lt;Key&gt;n</em> at the elements location and editing the old name in
the bottom input line. Naming pins and vias is similar to elements. 
You can hide the element name so that it won't appear on the board
silkscreen by pressing <em>&lt;key&gt;h</em> with the cursor over the element. 
Doing so again un-hides the element name.

<p>Entering <kbd>:le</kbd> and selecting an element data file is
the second way to load circuits.

<p>The third way to create a new element is to copy an existing one. 
Please refer to <a href="#Moving%20and%20Copying">Moving and Copying</a>.

<p>The fourth way to create a new element is to convert a buffer's contents
into an element.  Here's how it's done: Select the Via-tool from the
<em>Tool pallette</em>.  Set the grid spacing to something appropriate for
the element pin spacing.  Now create a series of vias where the pins
go.  Create them in pin number order. It is often handy to place a reference
point (<em>!Ctrl&lt;Key&gt;m</em>) in the center of the first pin in order to measure
the location of the other pins.  Next make a solder-side layer the active
layer from the <em>active-layer</em> popup menu.  Now draw the outline of
the element using lines and arcs.  When you're done, select everything that
makes up the element with a box selection (<em>&lt;Btn3Down&gt; drag,
&lt;Btn3Up&gt;</em>). Now select "cut selection to buffer" from the <em>Buffer</em>
menu. Position the cursor over the center of pin 1 and press the left
button to load the data into the buffer. 
Finally select "convert buffer to element" from the <em>Buffer</em> menu. 
You'll only want to create elements this way if they aren't already in the
library.  It's also probably a good idea to do this before starting any of
the other aspects of a layout, but it isn't necessary.

<p>To display the pinout of a circuit move to it and press <em>Shift&lt;Key&gt;d</em>
or select <em>show pinout</em> from the <em>Objects</em> menu. A new window
pops up and displays the complete pinout of the element. This display can
be difficult to read if the component has been rotated 90 degrees :-(
therefore, the new window will show an un-rotated view so the pin names
are readable. 
<em>&lt;Key&gt;d</em> displays the name of one or all pins/pads inside the
Layout area, this is only for display on-screen, it has no effect on any
printing of the layout.

<p>You also may want to change a pin's or pad's current size by pressing
<em>&lt;Key&gt;s</em> to increase or <em>Shift&lt;Key&gt;s</em> to decrease it. While
this is possible, it is not recommended since care was probably taken
to define the element structure in the first place. You can also change the thickness
of the element's silkscreen outline with the same keys. You can
change whether a pin or SMD pad is rounded or square with the <em>&lt;Key&gt;q</em>. 
SMD pads should usually have squared ends. Finally, you can change whether
the non-square pins are round or octagonal with the <em>!Ctrl&lt;Key&gt;o</em>.

<p>SMD elements and silkscreen objects are drawn in the "invisible object"
color if they are located on the opposite side of the board.

<p>For information on element connections refer to <a href="#Connection%20Lists">Connection Lists</a>.

<p><hr>
Node:<a name="Pastebuffer">Pastebuffer</a>,
Previous:<a rel=previous href="#Elements">Elements</a>,
Up:<a rel=up href="#Drawing%20and%20Removing">Drawing and Removing</a>
<br>

<h3>Pastebuffer</h3>

<p>The linestack and element-buffer of former releases have been replaced
by 5 (possibly more or less if changed at compile time
with the <code>MAX_BUFFER</code> variable in <code>globalconfig.h</code>)
multi-purpose buffers that are selected by
<em>Shift&lt;Key&gt;1..MAX_BUFFER</em>. The status line shows which buffer is
the active one. 
You may load data from a file or layout into them. 
Cut-and-paste works too. 
If you followed the instructions earlier in this chapter you should
now have several objects on the screen. Move the cross hair to one of them
and press <em>&lt;Btn3Down&gt;</em> to toggle its selection flag. (If you drag the
mouse while the button is down, a box selection will be attempted instead
of toggling the selection.)  The object
is redrawn in a different color. You also may want to try
moving the pointer while holding the third button down and
release it on a different location. This selects all objects inside the
rectangle and unselects everything else.  If you want to add a box selection
to an existing selection, drag with <em>Mod1&lt;Btn3Down&gt;</em> instead. 
Dragging <em>Shift Mod1&lt;Btn3Down&gt;</em> unselects objects in a box. 
Now change to <em>pastebuffer-mode</em> and select some operations from the
<em>Buffer</em> menu. Copying objects to the buffer is available as
<em>Mod1&lt;Key&gt;c</em> while cutting them uses <em>Mod1&lt;Key&gt;x</em> as
shortcut. Both clear the buffer before new data is added. 
If you use the menu entries, you have to supply a cross hair position by
pressing a mouse button. The objects are attached to the pastebuffer
relative to that cross hair location. 
Element data or PCB data may be merged into an existing layout by loading
the datafiles into the pastebuffer. Both operations are available from
the <em>File</em> menu or as user commands.

<p><hr>
Node:<a name="Moving%20and%20Copying">Moving and Copying</a>,
Next:<a rel=next href="#Loading%20and%20Saving">Loading and Saving</a>,
Previous:<a rel=previous href="#Drawing%20and%20Removing">Drawing and Removing</a>,
Up:<a rel=up href="#Getting%20Started">Getting Started</a>
<br>

<h2>Moving and Copying</h2>

<p>All objects can be moved including element-names, by
<em>&lt;Btn2Down&gt;</em>, draging the pointer while holding the button down
and releasing it at the new location of the object. If you use
<em>Mod1&lt;Btn2Down&gt;</em> instead, the object is copied. Copying does not work for
element-names of course. You can move all selected objects with
<em>Shift &lt;Btn1&gt;</em>.  This uses the Pastebuffer, so
it will remove whatever was previously in the Pastebuffer. 
Please refer to <a href="#Pastebuffer">Pastebuffer</a>. 
If you want to give a small nudge to an object, but you don't think
that the mouse will give you the fine level of control that you want,
you can position the cursor over the object, press <em>&lt;Key&gt;[</em>,
move it with the arrow keys, then press <em>&lt;Key&gt;]</em> when it's at the
desired position.  Remember that all movements are forced onto grid coordinates, so
you may want to change the grid spacing first.

<p><hr>
Node:<a name="Loading%20and%20Saving">Loading and Saving</a>,
Next:<a rel=next href="#Printing">Printing</a>,
Previous:<a rel=previous href="#Moving%20and%20Copying">Moving and Copying</a>,
Up:<a rel=up href="#Getting%20Started">Getting Started</a>
<br>

<h2>Loading and Saving</h2>

<p>After your first experience with <code>Pcb</code> you will probably want to save
your work. <kbd>:s name</kbd> passes the data to an external program which
is responsible for saving it. For details see <em>saveCommand</em> in
<a href="#Resources">Resources</a>. 
Saving also is available from the <em>File</em> menu, either with or
without supplying a filename. <code>Pcb</code> reuses the last
filename if you do not pass a new one to the save routine.

<p>To load an existing layout either select <em>load layout data</em> from the
<em>File</em> menu or use <kbd>:l filename</kbd>. A file select box pops up if you
don't specify a filename. Merging existing layouts into the new one is
supported either by the <em>File</em> menu or by <kbd>:m filename</kbd>.

<p><code>Pcb</code> saves a backup of the current layout depending on the resource
<em>backup</em>. The file is named <code>/tmp/PCB.%i.backup</code> by default
(this may have been changed at compilation time via the
<code>BACKUP_NAME</code>
variable in <code>globalconfig.h</code>).  During critical
sections of the program or when data would be lost it is saved as
<code>/tmp/PCB.%i.save</code>.  This file name may be changed at compile time
with the <code>DEFAULT_MEDIASIZE</code> variable in <code>globalconfig.h</code>.

<p><em>%i</em> is replaced by the process ID.

<p><hr>
Node:<a name="Printing">Printing</a>,
Next:<a rel=next href="#Connection%20Lists">Connection Lists</a>,
Previous:<a rel=previous href="#Loading%20and%20Saving">Loading and Saving</a>,
Up:<a rel=up href="#Getting%20Started">Getting Started</a>
<br>

<h2>Printing</h2>

<p><code>Pcb</code> now has support for device drivers,
<code>PostScript</code>, <em>encapsulated PostScript</em>,
and <em>Gerber RS-274-X</em> drivers are
available so far.  The <em>Gerber RS-274-X</em>
driver additionally generates a numerical control (NC) drill file for
automated drilling,
a bill of materials file to assist in materials procurement and
inventory control, and a centroid (X-Y) file which includes the
centroid data needed
by automatic assembly (pick and place) machines. 
 I recommend the use of <code>GhostScript</code> if you
don't have a <code>PostScript</code> printer for handling the PostScript
output. Printing always generates
a complete set of files for a specified driver. 
See the page about
the <em>Print()</em> action for addtional information about the filenames. 
The control panel offers a number of options. Most of them are not avilable
for Gerber output because it wouldn't make sense, for example,  to scale the gerber output
(you'd get an incorrectly made board!)  The options are:

<dl>
<dt><code>device</code>
<dd>The top menu button selects from the available device drivers.

<br><dt><code>rotate</code>
<dd>Rotate layout 90 degrees counter-clockwise before printing (default).

<br><dt><code>mirror</code>
<dd>Mirror layout before printing. Use this option depending
on your production line.

<br><dt><code>color</code>
<dd>Created colored output. All colors will be converted to black if this option
is inactive.

<br><dt><code>outline</code>
<dd>Add a board outline to the output file. The size is determined by the
maximum boardsize changeable from the <em>sizes</em> menu. The outline appears
on the top and bottom sides of the board, but not on the internal layers. 
An outline can be useful for determining where to shear the board from the
panel, but be aware that it creates a copper line.  Thus it has the potential
to cause short circuits if you don't leave enough room from your wiring
to the board edge.  Use a viewer to see what the output outline looks like
if you want to know what it looks like.

<br><dt><code>alignment</code>
<dd>Additional alignement targets are added to the output. The distances between
the board outline is set by the resource <em>alignmentDistance</em>.  Alignment
targets should only be used if you know for certain that YOU WILL BE USING
THEM YOURSELF.  It is extremely unlikely that you will want to have alignment
targets if you send gerber files to a commercial pcb manufacture to be made.

<br><dt><code>scaling</code>
<dd>It's quite useful to enlarge your printout for checking the layout. 
Use the scrollbar to adjust the scaling factor to your needs.

<br><dt><code>media</code>
<dd>Select the size of the output media from this menu. The user defined size
may be set by the resource <em>media</em> either from one of the well known
paper sizes or by a <code>X11</code> geometry specification. 
This entry is only available if you use <code>X11R5</code> or later. 
For earlier releases the user defined size or, if not available, <em>A4</em>
is used. 
Well known size are:
<pre>	A3
	A4
	A5
	letter
	tabloid
	ledger
	legal
	executive
</pre>

<br><dt><code>offset</code>
<dd>Adjust the offsets of the printout by using the panner at the right side
of the dialog box. 
This entry is only available if you use <code>X11R5</code> or later. A zero
offset is used for earlier releases.

<br><dt><code>8.3 filenames</code>
<dd>Select this button to generate DOS compatible filenames for the output files. 
The <em>command</em> input area will disappear if selected.

<br><dt><code>commandline</code>
<dd>Use this line to enter a command (starts with <kbd>|</kbd>) or a filename. 
A %f is replaced by the current filename. 
The default is set by the resource <em>printCommand</em>.

</dl>

<p>The created file includes some labels which are guaranteed to stay unchanged
<dl>
<dt><code>PCBMIN</code>
<dd>identifies the lowest x and y coordinates in mil.

<br><dt><code>PCBMAX</code>
<dd>identifies the highest x and y coordinates in mil.

<br><dt><code>PCBOFFSET</code>
<dd>is set to the x and y offset in mil.

<br><dt><code>PCBSCALE</code>
<dd>is a floating point value which identifies the scaling factor.

<br><dt><code>PCBSTARTDATA</code>
<dt><code>PCBENDDATA</code>
<dd>all layout data is included between these two marks. You may use them with an
<code>awk</code> script to produce several printouts on one piece of paper by
duplicating the code and putting some <code>translate</code> commands in front. 
Note, the normal <code>PostScript</code> units are 1/72 inch. 
</dl>

<p><hr>
Node:<a name="Connection%20Lists">Connection Lists</a>,
Next:<a rel=next href="#Arrow%20Tool">Arrow Tool</a>,
Previous:<a rel=previous href="#Printing">Printing</a>,
Up:<a rel=up href="#Getting%20Started">Getting Started</a>
<br>

<h2>Connection Lists</h2>

<p>After completing parts of your layout you may want to check if all drawn
connections match the ones you have in mind. This is probably best done
in conjunction with a net-list file: see <a href="#Rats%20Nest">Rats Nest</a>. 
The following examples give more rudimentary ways to examine
the connections.
<pre>    1) create at least two elements and name them
    2) create some connections between their pins
    3) optionally add some vias and connections to them
</pre>

<p>Now select <em>lookup connection</em> from the <em>Connections</em> menu,
move the cursor to a pin or via and press any mouse button. <code>Pcb</code>
will look for all other pins and/or vias connected to the one you have
selected and display the objects in a different color. 
Now try some of the reset options available from the same menu.

<p>There also is a way to scan all connections of one element. Select
<em>a single element</em> from the menu and press any button at the
element's location. All connections of this element will be saved
to the specified file. 
Either the layout name of the element or its canonical name is used to
identify pins depending on the one which is displayed on the screen
(may be changed by <em>Display</em> menu).

<p>An automatic scan of all elements is initiated by choosing
<em>all elements</em>. It behaves in a similar fashion to scanning a single
element except the resource <em>resetAfterElement</em>
is used to determine if connections should be reset before a new element is
scanned. Doing so will produce very long lists because the power lines are
rescanned for every element. By default the resource is set to <em>false</em>
for this reason.

<p>To scan for unconnected pins select <em>unused pins</em> from the same
menu.

<p><hr>
Node:<a name="Arrow%20Tool">Arrow Tool</a>,
Next:<a rel=next href="#Rats%20Nest">Rats Nest</a>,
Previous:<a rel=previous href="#Connection%20Lists">Connection Lists</a>,
Up:<a rel=up href="#Getting%20Started">Getting Started</a>
<br>

<h2>Arrow Tool</h2>

<p>Some commands mentioned earlier in this chapter also are able to operate on all
selected and visible objects. The Arrow tool is used to select/deselect
objects and also to move objects or selections.  If you click and release
on an object with the Arrow tool, it will unselect everything else and
select the object. Selected objects change color to reflect that
they are selected. If you <em>Shift</em> click, it will add the object to
(or remove) the object from the existing selection. If you drag with
the mouse button down with the Arrow tool, one of several things could
happen: if you first pressed the button on a selected object, you
will be moving the selection to where you release the button. If you
first pressed the button on an unselected object, you will be moving
that object. If you first pressed the button over empty space, you
will be drawing a box to select everything inside the box. The <em>Shift</em>
key works the same way with box selections as it does with single objects.

<p>Moving a single un-selected object is different from moving a selection. 
First of all, you can move the end of line, or a point in a polygon this
way which is impossible by moving selections. Secondly, if rubber banding
is turned on, moving a single object will rubber-band the attached lines. 
Finally, it is faster to move a single object this way since there is no need
to select it first.

<p>You can select any visible object unless it is locked. If you select an
object, then turn off its visibility with the Layer controls, it won't
be moved if you move the remaining visible selection.

<p>If you have not configured to use strokes in the <code>Pcb</code> user interface, then
the middle mouse button is automatically bound to the arrow tool, regardless
of the active tool (which is bound to the first mouse button). So using
the middle button any time is just like using the first mouse button
with the Arrow tool active.

<p>The entries of the <em>Selection</em> menu are hopefully self-explanatory. 
Many of the <em>Action Commands</em> can take various key words that make
them function on all or some of the selected items.

<p><hr>
Node:<a name="Rats%20Nest">Rats Nest</a>,
Next:<a rel=next href="#Design%20Rule%20Checking">Design Rule Checking</a>,
Previous:<a rel=previous href="#Arrow%20Tool">Arrow Tool</a>,
Up:<a rel=up href="#Getting%20Started">Getting Started</a>
<br>

<h2>Rats Nest</h2>

<p>If you have a netlist that corresponds to the layout you are working on, you
can use the rats-nest feature to add rat-lines to the layout. 
First you will need to load a netlist file (see <em>:rn</em>,
<a href="#User%20Commands">User Commands</a>). 
<em>&lt;Key&gt;w</em> adds rat-lines on the active layer using the current
line thickness shown in the status line (usually you'll want them to be thin lines). 
Only those rat-lines that fill in missing connectivity (since you have
probably routed some connections already) are added. 
If the layout is already completely wired, nothing will be added, and you will
get a message that the wiring is complete.

<p>Rat-lines are lines having the special property that they only connect to pins and
pads at their end points.  Rat-lines are drawn on the screen with a stippled pattern
to make them easier to identify since they have special behavior and cannot
remain in a completed layout. 
Rat-lines are added in the minimum length straight-line tree pattern
(always ending on pins or pads) that satisfies the missing connectivity in the circuit. 
Used in connection with moves and rotates of the elements, they are extremely useful for
deciding where to place elements on the board. The rat-lines will always automatically
rubberband to the elements whether or not the rubberband mode is on. The only way for
you to move them is by moving the parts they connect to. 
This is because it is never desireable to have the rat-lines disconnected from
their element pins.  Rat-lines will normally criss-cross
all over which gives rise to the name "rats nest" describing a layout connected with
them.  If a SMD pad is unreachable on the active layer, a warning will be issued
about it and the rat-line to that pad will not be generated.

<p>A common way to use rats nests is to place some
elements on the board, add the rat-lines, and then use a series of moves/rotates of the
elements until the rats nest appears to have minimum tangling.  You may want to iterate this step
several times. Don't worry if the layout looks messy - as long as you can get a sense for whether
the criss-crossing is better or worse as you move things, you're fine. 
After moving some elements arround, you may want to optimize the rats nest <em>&lt;Key&gt;o</em>
so that the lines are drawn between the closest points (this can change once you've moved components). 
Adding rat-lines only to selected pads/pins (<em>Shift&lt;Key&gt;w</em>)
is often useful to layout a circuit a little bit at a time. 
Sometimes you'll want to delete all the rat-lines (<em>&lt;Key&gt;e</em>) or
selected rat-lines (<em>Shift&lt;Key&gt;e</em>) in order to reduce confusion. 
With a little practice you'll be able to achieve a near optimal component placement with
the use of a rats nest.

<p>Rat-lines are not only used for assisting your element placement, they can also help
you to route traces on the board. 
Use the <em>&lt;Key&gt;m</em> to convert a rat-line under the cursor into
a normal line on the active layer. 
Inserting a point into a rat-line will also cause the two new lines to be normal lines
on the board. 
Another way that you can use rat-lines is to
use the <em>&lt;Key&gt;f</em> with the cursor over a pad or pin.  All of the pins and
pads and rat-lines belonging to that net will be highlighted. This is a helpful way to
distinguish one net from the rest of the rats nest.  You can then route those tracks,
turn off the highlighting (<em>Shift&lt;Key&gt;f</em>) and repeat the process. This will work even
if the layer that the rat-lines reside on is made invisible - so only the pins and pads
are highlighted. 
Be sure to erase the rat-lines (<em>&lt;Key&gt;e</em> erases them all) once you've
duplicated their connectivity by adding your own lines. 
When in doubt, the <em>&lt;Key&gt;o</em> will delete only those
rat-lines that are no longer needed.

<p>If connections exist on the board that are not listed in the netlist when
<em>&lt;Key&gt;w</em> is pressed, warning messages are issued and the affected pins and
pads are drawn in a special <em>warnColor</em> until the next <em>Notify()</em> event. 
If the entire layout agrees completely with the netlist, a message informs you that
the layout is complete and no rat-lines will be added (since none are needed). 
If the layout is complete, but still has rat-lines then you will be warned
that rat-lines remain. If you get no message at all it's probably because some
elements listed in the net list can't be found and where reported in an earlier
message. 
There shouldn't be any rat-lines left in a completed layout, only normal lines.

<p>The <em>Shift&lt;Key&gt;w</em> is used to add rat-lines to only those missing connections among
the selected pins and pads.  This can be used to add rat-lines in an incremental
manner, or to force a rat-line to route between two points that are not the
closest points within the net. Often it is best to add the rats nest in an incremental fashion, laying
out a sub-section of the board before going further. This is easy to accomplish since
new rat-lines are never added where routed connectivity already makes the necessary
connections.

<p><hr>
Node:<a name="Design%20Rule%20Checking">Design Rule Checking</a>,
Next:<a rel=next href="#Trace%20Optimizer">Trace Optimizer</a>,
Previous:<a rel=previous href="#Rats%20Nest">Rats Nest</a>,
Up:<a rel=up href="#Getting%20Started">Getting Started</a>
<br>

<h2>Design Rule Checking</h2>

<p>After you've finished laying out a board, you may want to check
to be certain that none of your interconnections are too closely
spaced or too tenuously touching to be reliably fabricated. The design
rule checking (DRC) function does this for you. Use the command ":DRC()" (without
the quotes of course) to invoke the checker.  If there are no problem areas,
you'll get a message to that effect.  If any problem is encountered, you will get
a message about it and the affected traces will be highlighted. One part of the
tracks of concern will be selected, while the other parts of concern will have the
"FindConnection" highlighting. The screen will automatically be centered in the
middle of the object having the "FindConnection" (Green) highlighting.  The middle of
the object is also the coordinates reported to be "near" the problem.  The actual trouble
region will be somewhere on the boundary of this object.  If the two parts are
from different nets then there is some place where they approach each
other closer than the minimum rule.  If the parts are from the same net, then
there is place where they are only barely connected. Find that place and connect
them better.

<p>After a DRC error is found and corrected you must run the DRC again because
the search for errors is halted as soon as the first problem is found. Unless you've
been extremely careless there should be no more than a few design rule errors
in your layout.  The DRC checker does not check for minimum spacing rules to
copper text, so always be very careful when adding copper text to a layout. 
The rules for the DRC are specified in the application resource file.  The minimum
spacing value (in mils) is given by the <em>Settings.Bloat</em> value. The default
is 7 mils. The minimum touching overlap (in mils) is given by the
<em>Settings.Shrink</em> value. This value defaults to 5 mils. Check with your
fabrication process people to determine the values that are right for you.

<p>If you want to turn off the highlighting produced by the DRC, perform an
undo (assuming no other changes have been made).  To restore the highlighting,
use redo.  The redo will restore the highlighting quickly without re-running
the DRC checker.

<p><hr>
Node:<a name="Trace%20Optimizer">Trace Optimizer</a>,
Previous:<a rel=previous href="#Design%20Rule%20Checking">Design Rule Checking</a>,
Up:<a rel=up href="#Getting%20Started">Getting Started</a>
<br>

<h2>Trace Optimizer</h2>

<p>PCB includes a flexible trace optimizer.  The trace optimizer can be run
after auto routing or hand routing to clean up the traces.

<dl>
<dt><b>Auto-Optimize</b>
<dd>Performs debumpify, unjaggy, orthopull, vianudge, and viatrim, in that
order, repeating until no further optimizations are performed.

<br><dt><b>Debumpify</b>
<dd>Looks for U shaped traces that can be shortened or eliminated.

<br><dt><b>Unjaggy</b>
<dd>Looks for corners which could be flipped to eliminate one or more
corners (i.e. jaggy lines become simpler).

<br><dt><b>Vianudge</b>
<dd>Looks for vias where all traces leave in the same direction. Tries to
move via in that direction to eliminate one of the traces (and thus a
corner).

<br><dt><b>Viatrim</b>
<dd>Looks for traces that go from via to via, where moving that trace to a
different layer eliminates one or both vias.

<br><dt><b>Orthopull</b>
<dd>Looks for chains of traces all going in one direction, with more traces
orthagonal on one side than on the other. Moves the chain in that
direction, causing a net reduction in trace length, possibly eliminating
traces and/or corners.

<br><dt><b>SimpleOpts</b>
<dd>Removing uneeded vias, replacing two or more trace segments in a row
with a single segment. This is usually performed automatically after
other optimizations.

<br><dt><b>Miter</b>
<dd>Replaces 90 degree corners with a pair of 45 degree corners, to reduce
RF losses and trace length.

</dl>

<p><hr>
Node:<a name="User%20Commands">User Commands</a>,
Next:<a rel=next href="#Command-Line%20Options">Command-Line Options</a>,
Previous:<a rel=previous href="#Getting%20Started">Getting Started</a>,
Up:<a rel=up href="#Top">Top</a>
<br>

<h1>User Commands</h1>

<p>The entering of user-commands is initiated by the action routine
<em>Command()</em> (the <code>(":")</code> character) and finished by either
<em>&lt;Key&gt;Return</em>
or <em>&lt;Key&gt;Escape</em> to confirm or to abort. These two keybindings
cannot be changed from the resource file. 
The triggering event, normally a key press, is ignored. 
The input area will replace the bottom statusline. It pops
up when <em>Command()</em> is called. The arguments of the user-commands
are passed to the external commands without modification. 
See also, the resource <em>saveInTMP</em>.

<p>There are simple <em>usage</em> dialogs for each command and one for the
complete set of commands.

<dl>

<br><dt><code>l [filename]</code>
<dd>Loads a new datafile (layout) and, if confirmed, overwrites any existing unsaved data. 
The filename and the searchpath (<em>filePath</em>) are passed to the
command defined by <em>fileCommand</em>. 
If no filename is specified a file select box will popup.

<br><dt><code>le [filename]</code>
<dd>Loads an element description into the paste buffer. 
The filename and the searchpath (<em>elementPath</em>) are passed to the
command defined by <em>elementCommand</em>. 
If no filename is specified a file select box will popup.

<br><dt><code>m [filename]</code>
<dd>Loads an layout file into the paste buffer. 
The filename and the searchpath (<em>filePath</em>) are passed to the
command defined by <em>fileCommand</em>. 
If no filename is specified a file select box will popup.

<br><dt><code>q[!]</code>
<dd>Quits the program without saving any data (after confirmation). 
q! doesn't ask for confirmation, it just quits.

<br><dt><code>s [filename]</code>
<dd>Data and the filename are passed to the command defined by the resource
<em>saveCommand</em>. It must read the layout data from <em>stdin</em>. 
If no filename is entered, either the last one is used
again or, if it is not available, a file select box will pop up.

<br><dt><code>rn [filename]</code>
<dd>Reads in a netlist file.  If no filename is given
a file select box will pop up. 
The file is read via the command defined by the
<em>RatCommand</em> resource. The command must send its output to <em>stdout</em>.

<p>Netlists are used for generating rat's nests (see <a href="#Rats%20Nest">Rats Nest</a>) and for
verifying the board layout (which is also accomplished by the <em>Ratsnest</em>
command).

<br><dt><code>w[q] [filename]</code>
<dd>These commands have been added for the convenience of <code>vi</code> users and
have the same functionality as <em>s</em> combined with <em>q</em>.

<br><dt><code>actionCommand</code>
<dd>Causes the actionCommand to be executed.  This allows you to initiate actions
for which no bindings exist in the resource file.  It can be used to initiate any
action with whatever arguments you enter.  This makes it possible to do things
that otherwise would be extremely tedious.  For example, to change the drilling
hole diameter of all vias in the layout to 32 mils, you could select everything using the
selection menu, then type "<em>:ChangeDrillSize(SelectedVias, 32)</em>".  (This will
only work provided the via's diameter is sufficiently large to accomodate a 32 mil hole). 
Another example might be to set the grid to 1 mil by typing "<em>:SetValue(Grid, 1)</em>". 
Note that some actions use the current cursor location, so be sure to place the cursor
where you want before entering the command.  This is one of my favorite new
features in 1.5 and can be a powerful tool. Study the <a href="#Actions">Actions</a> section to
see what actions are available.

</dl>

<p><hr>
Node:<a name="Command-Line%20Options">Command-Line Options</a>,
Next:<a rel=next href="#X11%20Interface">X11 Interface</a>,
Previous:<a rel=previous href="#User%20Commands">User Commands</a>,
Up:<a rel=up href="#Top">Top</a>
<br>

<h1>Command-Line Options</h1>

<p>There are several resources which may be set or reset in addition to the
standard toolkit command-line options. For a complete list refer to
<a href="#Resources">Resources</a>.

<p>The synopsis is:

<p><code>pcb [-option ...] [-toolkit_option ...] [layout-file]</code>

<p>or

<p><code>pcb -specialoption</code>

<ul>
<li><a href="#Options">Options</a>:                 <code>Pcb</code> command-line options. 
<li><a href="#Special%20Options">Special Options</a>:         Version and copyright information. 
</ul>

<p><hr>
Node:<a name="Options">Options</a>,
Next:<a rel=next href="#Special%20Options">Special Options</a>,
Up:<a rel=up href="#Command-Line%20Options">Command-Line Options</a>
<br>

<h2>Options</h2>

<dl>

<br><dt><code>-alldirections/+alldirections</code>
<dd>Disables or enables line clipping to 45 degree angles. Overwrites the
resource <em>allDirectionLines</em>.

<br><dt><code>-backup value</code>
<dd>Time between two backups in seconds. Passing zero disables the backup feature. 
Overwrites the resource <em>backupInterval</em>.

<br><dt><code>-c value</code>
<dd>Number of characters per output line. The resource <em>charactersPerLine</em> is
overwritten.

<br><dt><code>-fontfile filename</code>
<dd>The default set of symbols (font) for a new layout is read from this file. 
All directories as defined by the resource <em>fontPath</em> are scanned
for the file. The scan is only performed if the filename doesn't contain
a directory component. The <em>fontFile</em> resource is changed.

<br><dt><code>-lelement command-line</code>
<dd>Sets the command to be executed when an element is loaded from a file to the
paste buffer. The command may contain %f and %p to pass the requested filename
and the searchpath to the command. It must write the data to its
standard output. The related resource is <em>elementCommand</em>.

<br><dt><code>-lfile command-line</code>
<dd>Sets the command to be executed when a new layout is loaded from a file. 
The command may contain %f and %p to pass the requested filename
and the searchpath to the command. It must write the data to its
standard output. The related resource is <em>fileCommand</em>.

<br><dt><code>-lfont command-line</code>
<dd>Sets the command to be executed when a font is loaded from a file. 
The command may contain %f and %p to pass the requested filename
and the searchpath to the command. It must write the data to its
standard output. The related resource is <em>fontCommand</em>.

<br><dt><code>-lg layergroups</code>
<dd>This option overwrites the resource <em>layerGroups</em>. See its description
for more information. The value is used for new layouts only.

<br><dt><code>-libname filename</code>
<dd>The default filename for the library. Overwrites the resource
<em>libraryFilename</em>.

<br><dt><code>-libpath path</code>
<dd>The default search path for the the library. Overwrites the resource
<em>libraryPath</em>.

<br><dt><code>-llib command-line</code>
<dd>Sets the command to be executed when an element is loaded from the library. 
The command may contain %f and %p to pass the requested filename
and the searchpath to the command. %a is replaces by the three arguments
<em>template</em>, <em>value</em> and <em>package</em>. The command must write
the data to its standard output. The related resource is <em>libraryCommand</em>.

<br><dt><code>-llibcont command-line</code>
<dd>The command lists the contents of the library. 
The command may contain %f and %p to pass the library filename
and the searchpath to the command. Also refer to <a href="#Library%20File">Library File</a>
and <a href="#Library%20Contents%20File">Library Contents File</a>. 
The related resource is <em>libraryContentsCommand</em>.

<br><dt><code>-loggeometry geometry</code>
<dd>Determines the geometry of the log window.

<br><dt><code>-pnl value</code>
<dd>Restricts the displayed length of the name of a pin in the pinout window to
the passed value. See also, the resource <em>pinoutNameLength</em>.

<br><dt><code>-pz value</code>
<dd>Sets the zoom factor for the pinout window according to the formula:
scale = 1:(2 power value). The related resource is <em>pinoutZoom</em>.

<br><dt><code>-reset/+reset</code>
<dd>If enabled, all connections are reset after each element is scanned. 
This feature is only used while scanning connections to all elements. 
See also, <em>resetAfterElement</em>.

<br><dt><code>-ring/+ring</code>
<dd>Overrides the resource <em>ringBellWhenFinished</em>. If enabled, the bell
sounds when connection searching has finished.

<br><dt><code>-rs string</code>
<dd>Overrides the resource <em>routeStyle</em>. The string defines a colon
separated list of route styles. The route styles consist of a
comma separated list of name, line thickness, via diameter, and via drill size. 
e.g. "Fat,50,100,40:Skinny,8,35,20:75Ohm,110,110,20"

<br><dt><code>-s/+s</code>
<dd>Enables/Disables the saving of the previous commandline. Overrides the
<em>saveLastCommand</em> resource.

<br><dt><code>-save/+save</code>
<dd>See the resource description of <em>saveInTMP</em> for details.

<br><dt><code>-sfile command-line</code>
<dd>Sets the command to be executed when an layout file is saved. 
The command may contain %f which is replaced by the filename. The command
must read its data from the standard input. 
The resource <em>saveCommand</em> is overwritten.

<br><dt><code>-size &lt;width&gt;x&lt;height&gt;</code>
<dd>Overrides the resource <em>size</em> which determines the maximum size
of a layout.

<br><dt><code>-v value</code>
<dd>Sets the volume of the X speaker. The value is passed to <code>XBell()</code> and
must be in the range -100..100.

</dl>

<p><hr>
Node:<a name="Special%20Options">Special Options</a>,
Previous:<a rel=previous href="#Options">Options</a>,
Up:<a rel=up href="#Command-Line%20Options">Command-Line Options</a>
<br>

<h2>Special Options</h2>

<p>There are some special options available in addition to normal command line
options. Each of these must be the only option specified on a command line. 
The available special options are:

<dl>

<br><dt><code>-copyright</code>
<dd>Prints out the copyright notice and terminates.

<br><dt><code>-version</code>
<dd>Prints out the version ID and terminates.

<br><dt><code>-help</code>
<dd>Prints out the usage message and terminates.

</dl>

<p><hr>
Node:<a name="X11%20Interface">X11 Interface</a>,
Next:<a rel=next href="#File%20Formats">File Formats</a>,
Previous:<a rel=previous href="#Command-Line%20Options">Command-Line Options</a>,
Up:<a rel=up href="#Top">Top</a>
<br>

<h1>X11 Interface</h1>

<p>This chapter gives an overview about the additional <code>X11</code> resources which
are defined by <code>Pcb</code> as well as the defined action routines.

<ul>
<li><a href="#Resources">Resources</a>:       Non-standard <code>X11</code> application resources. 
<li><a href="#Actions">Actions</a>:         A list of available action routines. 
<li><a href="#Translations">Translations</a>:    A list of the default key translations (as shipped). 
</ul>

<p><hr>
Node:<a name="Resources">Resources</a>,
Next:<a rel=next href="#Actions">Actions</a>,
Up:<a rel=up href="#X11%20Interface">X11 Interface</a>
<br>

<h2>Non-Standard X11 Application Resources</h2>

<p>In addition to the toolkit resources, <code>Pcb</code> defines the
following resources:

<dl>

<br><dt><code>absoluteGrid (boolean)</code>
<dd>Selects if either the grid is relative to the position where it has changed
last or absolute, the default, to the origin (0,0).

<br><dt><code>alignmentDistance (dimension)</code>
<dd>Specifies the distance between the boards outline to the alignment targets.

<br><dt><code>allDirectionLines (boolean)</code>
<dd>Enables (default) or disables clipping of new lines to 45 degree angles.

<br><dt><code>backupInterval (int)</code>
<dd><code>Pcb</code> has an automatic backup feature which saves the current data
every n seconds. The default is <em>300</em> seconds. A value of zero disables
the feature. The backup file is named <code>/tmp/PCB.%i.backup</code> by
default (this may have been changed at compilation time via the
<code>BACKUP_NAME</code>
variable in <code>globalconfig.h</code>). 
<em>%i</em> is replaced by the process ID. 
See also, the command-line option <em>-backup</em>.

<br><dt><code>Bloat (dimension)</code>
<dd>Specifies the minimum spacing design rule in mils.

<br><dt><code>charactersPerLine (int)</code>
<dd><code>Pcb</code> uses this value to determine the page width when creating lists. 
N, the number of characters per line, defaults to <em>80</em>. 
See also, the command-line option <em>-c</em>.

<br><dt><code>connectedColor (color)</code>
<dd>All pins, vias, lines and rectangles which are selected during a connection
search are drawn with this color. The default value is determined by
<em>XtDefaultForeground</em>.

<br><dt><code>cross hairColor (color)</code>
<dd>This color is used to draw the cross hair cursor. The color is a result of
a <em>XOR</em> operation with the contents of the Layout area. The result
also depends on the default colormap of the <code>X11</code> server because only
the colormap index is used in the boolean operation and <code>Pcb</code> doesn't
create its own colormap. The default setting is <em>XtDefaultForeground</em>.

<br><dt><code>elementColor (color)</code>
<dt><code>elementSelectedColor (color)</code>
<dd>The elements package part is drawn in these colors, for normal and selected
mode, respectively, which both default to <em>XtDefaultForeground</em>.

<br><dt><code>elementCommand (string)</code>
<dd><code>Pcb</code> uses a user defined command to read element files. This resources
is used to set the command which is executed by the users default shell. 
Two escape sequences are defined to pass the selected filename (%f) and the
current search path (%p). The command must write the element data
to its standard output. The default value is
<pre>    M4PATH="%p";export M4PATH;echo 'include(%f)' | m4
</pre>
Using the GNU version of <code>m4</code> is highly recommended. 
See also, the command-line option <em>-lelement</em>.

<br><dt><code>elementPath (string)</code>
<dd>A colon separated list of directories or commands (starts with '|'). 
The path is passed to the program specified in <em>elementCommand</em> together
with the selected elementname. A specified command will be executed in order
to create entries for the fileselect box. It must write its results to
<em>stdout</em> one entry per line. 
See also, the user-command <em>le[!]</em>.

<br><dt><code>fileCommand (string)</code>
<dd>The command is executed by the user's default shell whenever existing layout
files are loaded. Data is read from the command's standard output. 
Two escape sequences may be specified to pass the selected filename (%f)
and the current search path (%p). The default value is:
<pre>    cat %f
</pre>
See also, the command-line option <em>-lfile</em>.

<br><dt><code>filePath (string)</code>
<dd>A colon separated list of directories or commands (starts with '|'). 
The path is passed to the program specified in <em>fileCommand</em> together
with the selected filename. A specified command will be executed in order
to create entries for the fileselect box. It must write its results to
<em>stdout</em> one entry per line. 
See also, the user-command <em>l[!]</em>.

<br><dt><code>fontCommand (string)</code>
<dd>Loading new symbol sets also is handled by an external command. You again
may pass the selected filename and the current search path by passing
%f and %p in the command string. Data is read from the commands standard
output. This command defaults to
<pre>    cat %f
</pre>
See also, the command-line option <em>-lfont</em>.

<br><dt><code>fontFile (string)</code>
<dd>The default font for new layouts is read from this file which is searched
in the directories as defined by the resource <em>fontPath</em>. 
Searching is only performed if the filename does not contain a directory
component. 
The default filename is <code>default_font</code>. 
See also, the command-line option <em>-fontfile</em>.

<br><dt><code>fontPath (string)</code>
<dd>This resource, a colon separated list of directories, defines the searchpath
for font files. See also, the resource <em>fontFile</em>.

<br><dt><code>grid (int)</code>
<dd>This resources defines the initial value of one cursor step. It defaults
to <em>100 mil</em> and any changes are saved together with the layout data.

<br><dt><code>gridColor (color)</code>
<dd>This color is used to draw the grid. The color is a result of
a <em>INVERT</em> operation with the contents of the Layout area. The result
also depends on the default colormap of the <code>X11</code> server because only
the colormap index is used in the boolean operation and <code>Pcb</code> doesn't
create its own colormap. The default setting is <em>XtDefaultForeground</em>.

<br><dt><code>elementColor (color)</code>
<dd>Elements localted on the opposite side of the board are drawn in this color. 
The default is <em>XtDefaultForeground</em>.

<br><dt><code>layerColor1..MAX_LAYER (color)</code>
<dt><code>layerSelectedColor1..MAX_LAYER (color)</code>
<dd>These resources define the drawing colors of the different layers in
normal and selected state. All values are preset to <em>XtDefaultForeground</em>.

<br><dt><code>layerGroups (string)</code>
<dd>The argument to this resource is a colon separated list of comma separated
layernumbers (1..MAX_LAYER). All layers within one group are switched on/off
together. The default setting is <em>1:2:3:...:MAX_LAYER</em> which means
all layers are handled separatly. Grouping layers one to three looks like
<em>1,2,3:4:...:MAX_LAYER</em>
See also, the command-line option <em>-lg</em>.

<br><dt><code>layerName1..MAX_LAYER (string)</code>
<dd>The default name of the layers in a new layout are determined by these
resources. The defaults are empty strings.

<br><dt><code>libraryCommand (string)</code>
<dd><code>Pcb</code> uses a command to read element data from libraries. 
The resources is used to set the command which is executed by the users
default shell.  Three escape sequences are defined to pass the selected
filename (%f), the current search path (%p) as well (%a) as the three
parameters <em>template</em>, <em>value</em> and <em>package</em> to the command. 
It must write the element data to its standard output. The default value is
<pre>    NONE/share/pcb/oldlib/QueryLibrary.sh %p %f %a
</pre>

<br><dt><code>libraryContentsCommand (string)</code>
<dd>Similar to <em>libraryCommand</em>, <code>Pcb</code> uses the command specified
by this resource to list the contents of a library.
<pre>	NONE/share/pcb/oldlib/ListLibraryContents.sh %p %f
</pre>
is the default.

<br><dt><code>libraryFilename (string)</code>
<dd>The resource specifies the name of the library. The default value is
<em>pcblib</em> unless changed at compile time
with the <code>LIBRARYFILENAME</code> variable in <code>globalconfig.h</code>.

<br><dt><code>libraryPath (string)</code>
<dd>A colon separated list of directories that will be passed to the commands
specified by <em>elementCommand</em> and <em>elementContentsCommand</em>.

<br><dt><code>lineThickness (dimension)</code>
<dd>The value, in the range [1..250] (the range may be changed at compile
time with the <code>MIN_LINESIZE</code> and <code>MAX_LINESIZE</code> variables in
<code>globalconfig.h</code>), defines the
initial thickness of new lines. The value is preset to <em>ten mil</em>.

<br><dt><code>media (&lt;predefined&gt; | &lt;width&gt;x&lt;height&gt;+-&lt;left_margin&gt;+-&lt;top_margin&gt;)</code>
<dd>The default (user defined) media of the <code>PostScript</code> device. Predefined
values are <em>a3</em>, <em>a4</em>, <em>a5</em>, <em>letter</em>, <em>tabloit</em>,
<em>ledger</em>, <em>legal</em>, and <em>executive</em>. 
The second way is to specify the medias width, height and margins in mil. 
The resource defaults to <em>a4</em> size unless changed at compile time
with the <code>DEFAULT_MEDIASIZE</code> variable in <code>globalconfig.h</code>.

<br><dt><code>offLimitColor (color)</code>
<dd>The area outside the current maximum settings for width and height is drawn
with this color. The default value is determined by <em>XtDefaultBackground</em>.

<br><dt><code>pinColor (color)</code>
<dt><code>pinSelectedColor(color)</code>
<dd>This resource defines the drawing color of pins and pads in both states. 
The values are preset to <em>XtDefaultForeground</em>.

<br><dt><code>pinoutFont (string)</code>
<dd>This fonts are used to display pin names. There is one font for each zoom
value. The values are preset to <em>XtdefaultFont</em>.

<br><dt><code>pinoutNameLength (int)</code>
<dd>This resource limits the number of characters which are displayed for
pin names in the pinout window. By default the string length is limited
to <em>eight</em> characters per name. 
See also, the command-line option <em>-pnl</em>.

<br><dt><code>pinoutOffsetX (int)</code>
<dt><code>pinoutOffsetY (int)</code>
<dd>These resources determine the offset in <em>mil</em> of the circuit from the
upper left corner of the window when displaying pinout information. 
Both default to <em>100 mil</em>.

<br><dt><code>pinoutTextOffsetX (int)</code>
<dt><code>pinoutTextOffsetY (int)</code>
<dd>The resources determine the distance in mil between the drilling hole of a pin
to the location where its name is displayed in the pinout window. 
They default to <em>X:50</em> and <em>Y:0</em>.

<br><dt><code>pinoutZoom (int)</code>
<dd>Sets the zoom factor for the pinout window according to the formula:
scale = 1:(2 power value). Its default value is <em>two</em> which results in
a <em>1:4</em> scale. 
See also, the command-line option <em>-pz</em>.

<br><dt><code>printCommand (string)</code>
<dd>Default file for printouts. If the name starts with a '|' the output
is piped through the command. A %f is replaced by the current filename. 
There is no default file or command.

<br><dt><code>raiseLogWindow (boolean)</code>
<dd>The log window will be raised when new messages arrive if this resource
is set <em>true</em>, the default.

<br><dt><code>ratCommand (string)</code>
<dd>Default command for reading a netlist. A %f is replaced by the netlist
filename. Its default value is "<em>cat %f</em>".

<br><dt><code>ratPath (string)</code>
<dd>Default path to look for netlist files. It's default value is "."

<br><dt><code>resetAfterElement (boolean)</code>
<dd>If set to <em>true</em>, all found connections will be reset before a new
element is scanned. This will produce long lists when scanning the whole
layout for connections. The resource is set to <em>false</em> by default. 
The feature is only used while looking up connections of all elements. 
See also, the command-line option <em>-reset, +reset</em>.

<br><dt><code>ringBellWhenFinished (boolean)</code>
<dd>Whether to ring the bell (the default) when a possibly lengthy operation
has finished or not. 
See also, the command-line option <em>-ring, +ring</em>.

<br><dt><code>routeStyle (string)</code>
<dd>Default values for the menu of routing styles (seen in the sizes menu). 
The string is a comma separated list of name, line thickness,
via diameter, and via drill size. 
e.g. "Fat,50,100,40:Skinny,8,35,20:75Ohm,110,110,20"
See also, the command-line option <em>-rs</em> and <em>Sizes Menu</em>

<br><dt><code>rubberBandMode (boolean)</code>
<dd>Whether rubberband move and rotate (attached lines stretch like
rubberbands) is enabled (the default).

<br><dt><code>saveCommand (string)</code>
<dd>This command is used to save data to a layout file. The filename may be
indicated by placing <code>%f</code> in the string. It must read the data from
its standard input.  The default command is:
<pre>    cat - &gt; %f
</pre>
See also, the command-line option <em>-sfile</em>.

<br><dt><code>saveInTMP (boolean)</code>
<dd>Enabling this resource will save all data which would otherwise be lost
in a temporary file <code>/tmp/PCB.%i.save</code>.  The file name may
be changed at compile time
with the <code>EMERGENCY_NAME</code> variable in <code>globalconfig.h</code>. 
. 
<em>%i</em> is replaced by the process ID. 
As an example, loading a new layout when the old one hasn't been saved would
use this resource. 
See also, the command-line option <em>-save, +save</em>.

<br><dt><code>saveLastCommand (boolean)</code>
<dd>Enables the saving of the last entered user command. The option is
<em>disabled</em> by default. 
See also, the command-line option <em>-s, +s</em>.

<br><dt><code>Shrink (dimension)</code>
<dd>Specifies the minimum overlap (touching) design rule in mils.

<br><dt><code>size (&lt;width&gt;x&lt;height&gt;)</code>
<dd>Defines the width and height of a new layout. The default is
<em>7000x5000</em> unless changed at compile time
with the <code>DEFAULT_SIZE</code> variable in <code>globalconfig.h</code>.

<br><dt><code>stipllePolygons (boolean)</code>
<dd>Determines whether to display polygons on the screen with a stippled
pattern.  Stippling can create some amount of transperency so that
you can still (to some extent) see layers beneath polygons. 
It defaults to False.

<br><dt><code>textScale (dimension)</code>
<dd>The font scaling in percent is defined by this resource. The default is
<em>100</em> percent.

<br><dt><code>useLogWindow (boolean)</code>
<dd>Several subroutines send messages to the user if an error occurs. 
This resource determines if they appear inside the log window or as a separate
dialog box. See also, the resource <em>raiseLogWindow</em> and the command line
option <em>-loggeometry</em>. 
The default value is <em>true</em>.

<br><dt><code>viaColor (color)</code>
<br><dt><code>viaSelectedColor (color)</code>
<dd>This resource defines the drawing color of vias in both states. 
The values are preset to <em>XtDefaultForeground</em>.

<br><dt><code>viaThickness (dimension)</code>
<dt><code>viaDrillingHole (dimension)</code>
<dd>The initial thickness and drilling hole of new vias. The values must be in the
range [30..400] (the range may be changed at compile
time with the <code>MIN_PINORVIASIZE</code> and <code>MAX_PINEORVIASIZE</code> variables in
<code>globalconfig.h</code>), with at least 20
mil of copper. 
The default thickness is <em>40 mil</em> and the default drilling hole is
<em>20 mil</em>.

<br><dt><code>volume (int)</code>
<dd>The value is passed to <code>XBell()</code> which sets the volume of the <code>X</code>
speaker. 
The value lies in the range -100..100 and it defaults to the maximum volume of
<em>100</em>.

<br><dt><code>warnColor (color)</code>
<dd>This resources defines the color to be used for drawing pins and pads when
a warning has been issued about them.

<br><dt><code>zoom (int)</code>
<dd>The initial value for output scaling is set according to the following
formula: scale = 1:(2 power value). It defaults to <em>three</em> which results
in an output scale of <em>1:8</em>.

</dl>

<p>Refer also to <a href="#Command-Line%20Options">Command-Line Options</a>.

<p><hr>
Node:<a name="Actions">Actions</a>,
Next:<a rel=next href="#Translations">Translations</a>,
Previous:<a rel=previous href="#Resources">Resources</a>,
Up:<a rel=up href="#X11%20Interface">X11 Interface</a>
<br>

<h2>Actions</h2>

<p>All user accessible commands may be bound to almost any <code>X</code> event. Almost
no default binding for commands is done in the binaries, so it is vital for the
application that at least a system-wide application resource file exists. 
This file normally resides in the <code>share/pcb</code> directory and
is called <code>Pcb</code>. The bindings to which the manual refers to are the
ones as defined by the shipped resource file. Besides binding an action to
an X11 event, you can also execute any action command using a ":" command
(see <a href="#User%20Commands">User Commands</a>).

<p>Take special care about translations related to the functions keys and the
pointer buttons because most of the window managers use them too. 
Change the file according to your hardware/software environment. 
You may have to replace all occurances of <em>baseTranslations</em> to
<em>translations</em> if you use a <code>X11R4</code> server.

<p>Passing <em>Object</em> as an argument to an action routine causes the object
at the cursor location to be changed, removed or whatever. If more than
one object is located at the cross hair position the smallest type is used. 
If there are two of the same type the newer one is taken. 
<em>SelectedObjects</em> will handle all selected and visible objects.

<dl>
<dt><code>AddRats(AllRats|SelectedRats)</code>
<dd>Adds rat-lines to the layout using the loaded netlist file (see the <em>:rn</em>,
<a href="#User%20Commands">User Commands</a>.). Rat lines are added on the active layer using the current
line thickness shown in the status line. 
Only missing connectivity is added by the
AddRats command so if, for example, the layout is complete nothing will be added. 
Rat lines are drawn on the screen with a stippled pattern
to make them easier to identify since they cannot appear in a completed layout. 
The rat-lines are added in the minimum length straight-line tree pattern
(always ending on pins or pads) that satisfies the missing connectivity in the circuit. 
If a SMD pad is unreachable on the active layer, a warning will be issued
about it and the rat-line to that pad will not be generated. 
If connections exist on the board which are not listed in the netlist while
AllRats are being added, warning messages will be issued and the affected pins and
pads will be drawn in a special <em>warnColor</em> until the next <em>Notify()</em> event. 
If the entire layout agrees completely with the net-list a message informs you that
the layout is complete and no rat-lines are added (since none are needed). 
If <em>SelectedRats</em>
is passed as the argument, only those missing connections that might connect among
the selected pins and pads are drawn. 
Default:
<pre>None&lt;Key&gt;w:	AddRats(AllRats)
!Shift&lt;Key&gt;w:	AddRats(SelectedRats)
None&lt;Key&gt;o:	DeleteRats(AllRats) AddRats(AllRats)
!Shift&lt;Key&gt;o:	DeleteRats(SelectedRats) AddRats(SelectedRats)
</pre>

<br><dt><code>Atomic(Save|Restore|Block|Close)</code>
<dd>Controls the undo grouping of sequences of actions. Before the first action
in a group, Atomic(Save) should be issued.  After each action that might
be undoable, Atomic(Restore) should be issued.  Atomic(Block) concludes
and save the undo grouping if there was anything in the group to undo. 
Atomic(Close) concludes and save the undo grouping even if nothing was
actually done.  Thus it might produce an "empty" undo.  This can be useful
when you want to use undo in a group of actions.

<br><dt><code>Bell([-100..100])</code>
<dd>Rings the bell of your display. If no value is passed the setting
of the resource <em>volume</em> will be used.

<br><dt><code>ChangeDrillSize(Object, value)</code>
<dt><code>ChangeDrillSize(SelectedPins|SelectedVias, value)</code>
<dd>This action routine changes the drilling hole of pins and vias. 
If <em>value</em> starts with + or -, then it adds (or subtracts)
<em>value</em> from the current hole diameter, otherwise it sets the
diameter to the value. 
Default:
<pre>!Mod1&lt;Key&gt;s:       Change2ndSize(Object, +5)
!Mod1 Shift&lt;Key&gt;s: Change2ndSize(Object, -5)
</pre>

<dt><code>ChangeFlag(Object|SelectElements|SelectedPins|SelectedVias|Selected,thermal|octagon|square,0|1)</code>
<dd>Sets/clears the indicated flag.  This adds/removes thermals, adds/removes the flag
which indicates a pin/pad should be square, or adds/removes the flag which
indicates a pin/pad should be octagonal.
<pre>:ChangeFlag(SelectedVias,thermal,1)
:ChangeFlag(SelectedPads,square,0)
</pre>

<br><dt><code>ChangeHole(Object|SelectedVias)</code>
<dd>This action routine converts a via to and from a hole.  A hole is
a via that has no copper annulus. The drill size for the via
determines the hole diameter.
<pre>!Ctrl&lt;Key&gt;h:	ChangeHole(Object)
</pre>

<br><dt><code>ChangeName(Object)</code>
<dt><code>ChangeName(Layer|Layout)</code>
<dd>Changes the name of the visible object at the cursor location. A text object
doesn't have a name therefore the text string itself is changed. 
The element name currently used for display is always the one changed with this
command. 
See <em>Display(Description|NameOnPCB|Value)</em> for details. 
Passing <em>Layer</em> changes the current layers name. 
Default:
<pre>None&lt;Key&gt;n: ChangeName(Object)
</pre>

<dt><code>ChangeOctagon(Object|SelectElements|SelectedPins|SelectedVias|Selected)</code>
<dd>Toggles what shape the affected pin(s) or via(s) will be drawn when they
are not square. The shape will either be round or octagonal. 
Default:
<pre>!Ctrl&lt;Key&gt;o: ChangeOctagon(Object)
</pre>

<br><dt><code>ChangeSize(Object, value)</code>
<dt><code>ChangeSize(SelectedLines|SelectedPins|SelectedVias, value)</code>
<dt><code>ChangeSize(SelectedPads|SelectedTexts|SelectedNames, value)</code>
<dt><code>ChangeSize(SelectedElements, value)</code>
<dd>To change the size of an object you have to bind these action to some
<code>X</code> event (or use :ChangeSize(...)).  If <em>value</em> begins with
a + or - then the value will be added (or subtracted) from the current
size, otherwise the size is set equal to <em>value</em>. Range checking is
done to insure that none of the maximum/minimums of any size are violated. 
If <em>Object</em> is passed then a single object at the cursor location is
changed. If any of the <em>Selected</em> arguments are passed then all selected
and visible objects of that type are changed. If the type being modified is
an element, then the thickness of the silkscreen lines defining the element
is changed. 
Default:
<pre>None&lt;Key&gt;s:   ChangeSize(Object, +5)
!Shift&lt;Key&gt;s: ChangeSize(Object, -5)
</pre>

<br><dt><code>ChangeSquare(Object|SelectedElements|SelectedPins)</code>
<dd>Toggles the setting of the square flag. The flag is used to identify a
certain pin, normally the first one, of circuits. It is also used to
make SMD pads have square ends.
<pre>None&lt;Key&gt;q:   ChangeSquare(Object)
</pre>

<dt><code>ClrFlag(Object|SelectElements|SelectedPins|SelectedVias|Selected,thermal|octagon|square)</code>
<dd>Clears the indicated flag.  This removes thermals, removes the flag
which indicates a pin/pad should be square, or removes the flag which
indicates a pin/pad should be octagonal.
<pre>:ClrFlag(SelectedVias,thermal)
</pre>

<br><dt><code>Command()</code>
<dd>Calling <em>Command()</em> pops up an input line at the bottom of the window
which allows you to enter commands. Including all action commands! 
The dialog ends when <em>None&lt;Key&gt;Return</em>
to confirm or <em>None&lt;Key&gt;Escape</em> to abort is entered. 
Default:
<pre>&lt;Key&gt;colon: Command()
</pre>

<br><dt><code>Connection(Find)</code>
<dt><code>Connection(ResetFoundLinesAndRectangles|ResetPinsViasAndPads|Reset)</code>
<dd>The <em>Connection()</em> action is used to mark all connections from one pin,
line or via to others. 
The <em>ResetFoundLinesAndRectangles, ResetFoundPinsAndVias</em> and
<em>Reset</em> arguments may be used to reset all marked lines and rectangles,
vias and pins or all of them. The search starts with the pin or via
at the cursor position. All found objects are drawn with the color
defined by the resource <em>connectedColor</em>. 
See also, <em>Display(Description|NameOnPCB|Value)</em>. 
Default:
<pre>!Shift&lt;Key&gt;c: Connection(Reset)
None&lt;Key&gt;f:   Connection(Find)
!Shift&lt;Key&gt;f: Connection(Reset)
</pre>

<br><dt><code>DeleteRats(AllRats|SelectedRats)</code>
<dd>This routine deletes either all rat-lines in the layout, or only
the selected and visible ones. Non-rat-lines and other layout
objects are unaffected. 
Default:
<pre>None&lt;Key&gt;e:   DeleteRats(AllRats)
!Shift&lt;Key&gt;e: DeleteRats(SelectedRats)
</pre>

<br><dt><code>Display(Description|NameOnPCB|Value)</code>
<dt><code>Display(Toggle45Degree|CycleClip)</code>
<dt><code>Display(Grid|ToggleGrid)</code>
<dt><code>Display(ToggleRubberBandMode)</code>
<dt><code>Display(Center|ClearAndRedraw|Redraw)</code>
<dt><code>Display(Pinout|PinOrPadName)</code>
<dd>This action routines handles some output related settings. It is
used to center the display around the cursor location and to redraw the
output area optionally after clearing the window. 
Centering is done with respect to the <em>grid</em> setting. Displaying the
grid itself may be switched on and off by <em>Grid</em> but only if
the distance between two pixels exceeds 4 pixels. 
<code>Pcb</code> is able to handle several labels of an element. One of them
is a description of the functionality (eg resistor), the second should be
a unique identifier (R1) whereas the last one is a value (100k). 
The <em>Display()</em> action selects which of the names is displayed. 
It also controls which name will be affected by the <em>ChangeName</em> command. 
If <em>ToggleGrid</em> is passed, <code>Pcb</code> changes between relative
('rel' in the statusline) and absolute grid (an 'abs' in the statusline). 
Relative grid means the pointer position when the command is issued is
used as the grid origin; while (0,0) is used in the absolute grid case. 
Passing <em>Pinout</em> displays the pinout of the element at the current
cursor location whereas <em>PinOrPadName</em> toggles displaying of the
pins or pads name under the cursor. If none of them matches but the cursor
is inside of an element, the flags is toggled for all of its pins and pads. 
For details about rubberbands see also the details about <em>Mode</em>. 
Default:
<pre>None&lt;Key&gt;c:  Display(Center)
None&lt;Key&gt;d:  Display(PinOrPadName)
!Shift&lt;Key&gt;d: Display(Pinout)
None&lt;Key&gt;r:  Display(ClearAndRedraw)
None&lt;Key&gt;.:  Display(Toggle45Degree)
None&lt;Key&gt;/:  Display(CycleClip)
</pre>

<br><dt><code>DRC()</code>
<dd>Initiates design rule checking of the entire layout. Must be repeated
until no errors are found.

<br><dt><code>EditLayerGroups()</code>
<dd>Pops up a dialog box to edit the layergroup setting. The function is also
available from the <em>Objects</em> menu. 
There are no defaults.

<br><dt><code>Load(ElementToBuffer|Layout|LayoutToBuffer|Nelist)</code>
<dd>This routine pops up a fileselect box to load layout, element data,
or netlist. 
The passed filename for layout data is saved and may be reused. 
<em>ElementToBuffer</em> and <em>LayoutToBuffer</em> load the data into the
current buffer. 
There are no defaults.

<br><dt><code>MarkCrosshair()</code>
<dd>This routine marks the current cursor location with an X, and then
the cursor display shows both absolute position and position relative to
the mark.  If a mark is already present, this routine removes it and
stops displaying relative cursor coordinates. 
Defaults:
<pre>!Ctrl&lt;key&gt;m:	MarkCrosshair()
</pre>

<br><dt><code>Mode(Copy|InsertPoint|Line|Move|None|PasteBuffer|Polygon|Thermal)</code>
<dt><code>Mode(Remove|Rectangle|RubberbandMove|Text|Via)</code>
<dt><code>Mode(Cycle)</code>
<dt><code>Mode(Notify)</code>
<dt><code>Mode(Save|Restore)</code>
<dd>Switches to a new mode of operation. The active mode is displayed by a thick
line around the matching mode selector button. 
Most of the functionality of <code>Pcb</code> is implemented by selecting a mode
and calling <em>Mode(Notify)</em>. The arguments <em>Line</em>, <em>Polygon</em>,
<em>Rectangle</em>, <em>Text</em> and <em>Via</em> are used to create the
appropriate object whenever <em>Mode(Notify)</em> is called. Some of them,
such as <em>Polygon</em>, need more than one call for one object to be created. 
<em>InsertPoint</em> adds points to existing polygons or lines. 
<em>Save</em> and <em>Restore</em> are used to temporarily save the mode, switch
to another one, call <em>Mode(Notify)</em> and restore the saved one. Have
a look at the application resource file for examples. 
<em>Copy</em> and <em>Move</em> modes are used to change an object's location and,
optionally, to create a new one. The first call of <em>Mode(Notify)</em> attaches
the object at the pointer location to the cross hair whereas the second
one drops it to the layout. The <em>rubberband</em> version of move performs the
move while overriding the current rubberband mode. 
Passing <em>PasteBuffer</em> attaches the contents of the currently selected
buffer to the cross hair. Each call to <em>Mode(Notify)</em> pastes this contents
to the layout. <em>Mode(Cycle)</em> cycles through the modes available in the
mode-button pallete. 
<em>Mode(None)</em> switches all modes off. 
Default:
<pre>&lt;Key&gt;Escape:             Mode(None)
&lt;Key&gt;space:              Mode(Cycle)
None&lt;Key&gt;BackSpace:      Mode(Save) Mode(Remove) Mode(Notify) Mode(Restore)
None&lt;Key&gt;Delete:         Mode(Save) Mode(Remove) Mode(Notify) Mode(Restore)
None&lt;Key&gt;F1:             Mode(Via)
None&lt;Key&gt;F2:             Mode(Line)
None&lt;Key&gt;F3:             Mode(PasteBuffer)
None&lt;Key&gt;F4:             Mode(Rectangle)
None&lt;Key&gt;F5:             Mode(Text)
None&lt;Key&gt;F6:             Mode(Polygon)
None&lt;Key&gt;F7:             Mode(Thermal)
None&lt;Key&gt;F8:		 Mode(Arc)
None&lt;Key&gt;Insert:         Mode(InsertPoint)
None&lt;Key&gt;[:              Mode(Save) Mode(Move) Mode(Notify)
None&lt;Key&gt;]:              Mode(Notify) Mode(Restore)
None&lt;Btn1&gt;:          Mode(Notify)
!Shift Ctrl&lt;Btn1&gt;:   Mode(Save) Mode(Remove) Mode(Notify) Mode(Restore)
None&lt;Btn2Down&gt;:          Mode(Save) Mode(Move) Mode(Notify)
None&lt;Btn2Up&gt;:            Mode(Notify) Mode(Restore)
!Mod1&lt;Btn2Down&gt;:       Mode(Save) Mode(Copy) Mode(Notify)
!Mod1&lt;Btn2Up&gt;:         Mode(Notify) Mode(Restore)
Shift BTNMOD&lt;Btn2Down&gt;: Mode(Save) Mode(RubberbandMove) Mode(Notify)
</pre>

<br><dt><code>MovePointer(delta_x, delta_y)</code>
<dd>With this function it is possible to move the cross hair cursor by using the
cursor keys. The <code>X</code> server's pointer follows because the necessary
events are generated by <code>Pcb</code>. All movements are performed with respect
to the currently set grid value. 
Default:
<pre>None&lt;Key&gt;Up:      MovePointer(0, -1)
!Shift&lt;Key&gt;Up:    MovePointer(0, -10)
None&lt;Key&gt;Down:    MovePointer(0, 1)
!Shift&lt;Key&gt;Down:  MovePointer(0, 10)
None&lt;Key&gt;Right:   MovePointer(1, 0)
!Shift&lt;Key&gt;Right: MovePointer(10, 0)
None&lt;Key&gt;Left:    MovePointer(-1, 0)
!Shift&lt;Key&gt;Left:  MovePointer(-10, 0)
</pre>

<br><dt><code>MoveToCurrentLayer(Object|SelectedObjects)</code>
<dd>The function moves a single object at the cross hair location or all selected
objects to the current layer. Elements are not moveable by this function. 
They have to be deleted and replaced on the other side. 
If a line segment is moved and the movement would result in a loss of
connectivity to another segment then via(s) are automatically added to
maintain the connectivity.
<pre>None&lt;Key&gt;m:       MoveToCurrentLayer(Object)
!Shift&lt;Key&gt;m:     MoveToCurrentLayer(SelectedObjects)
</pre>

<br><dt><code>New()</code>
<dd>Clear the current layout and starts a new one after entering its name. 
Refer to the resource <em>backup</em> for more information. 
No defaults.

<br><dt><code>PasteBuffer(AddSelected|Clear|1..5)</code>
<dt><code>PasteBuffer(Rotate, 1..3)</code>
<dt><code>PasteBuffer(Convert)</code>
<dd>This action routine controls and selects the pastebuffer as well as all
cut-and-paste operations. Passing a buffer number selects one in of the
range 1..5. The statusline is updated with the new number. 
<em>Rotate</em> performs a number of 90 degree counter clockwise rotations
of the buffer contents. <em>AddSelected</em> as first argument copies all
selected and visible objects into the buffer. Passing <em>Clear</em> removes
all objects from the currently selected buffer. <em>Convert</em> causes
the contents of the buffer (lines, arc, vias) to be converted into an
element definition. Refer to <a href="#Pastebuffer">Pastebuffer</a>
for examples. 
Default:
<pre>!Ctrl&lt;Key&gt;x:       PasteBuffer(Clear) PasteBuffer(AddSelected)
                   Mode(PasteBuffer)
!Shift Ctrl&lt;Key&gt;x: PasteBuffer(Clear) PasteBuffer(AddSelected)
                   RemoveSelected() Mode(PasteBuffer)
!Mod1&lt;Key&gt;c:       PasteBuffer(Clear) PasteBuffer(AddSelected)
!Mod1&lt;key&gt;x:       PasteBuffer(Clear) PasteBuffer(AddSelected)
		   RemoveSelected()
!Shift&lt;Key&gt;1:      PasteBuffer(1)
!Shift&lt;Key&gt;2:      PasteBuffer(2)
!Shift&lt;Key&gt;3:      PasteBuffer(3)
!Shift&lt;Key&gt;4:      PasteBuffer(4)
!Shift&lt;Key&gt;5:      PasteBuffer(5)
None&lt;Key&gt;F3:       Mode(PasteBuffer)
</pre>

<br><dt><code>Polygon((Close|PreviousPoint)</code>
<dd>Polygons need a special action routine to make life easier. Calling
<em>Polygon(PreviousPoint)</em> resets the newly entered corner to the
previous one. The Undo action will call Polygon(PreviousPoint)
when appropriate to do so.  <em>Close</em> creates the final
segment of the polygon.  This may fail if clipping to 45 degree
lines is switched on, in which case a warning is issued. 
Default:
<pre>None&lt;Key&gt;p:             Polygon(Close)
!Shift&lt;Key&gt;p:           Polygon(Close)
</pre>

<br><dt><code>Print()</code>
<dd>Pops up a print control box that lets you select the output
device, scaling and many more options. Each run creates all
files that are supported by the selected device. These are
mask files as well as drilling files, silk screens and so on. The table
shows the filenames for all possible files:
<pre>        POSIX (extention)             8.3 filename
		---------------------------------------------
		*_componentmask.*             cmsk.*
		*_componentsilk.*             cslk.*
		*_soldermask.*                smsk.*
		*_soldersilk.*                sslk.*
		*_drill.*                     dril.*
		*_groundplane.*               gpl.*
		*_group[1..8].*     [..8].*
</pre>
The output may be sent to a postprocessor by starting the filename with the
<em>pipe</em> <code>("|")</code> character. Any <code>"%f"</code> in a command is replaced
with the current filename. The function is available from the <em>file</em> menu. 
There are no defaults.

<br><dt><code>Quit()</code>
<dd>Quits the application after confirming the operation. 
Default:
<pre>&lt;Message&gt;WM_PROTOCOLS: Quit()
</pre>

<br><dt><code>Redo()</code>
<dd>This routine allows you to recover from the last undo command. 
You might want to do this if you thought that undo was going to
revert something other than what it actually did (in case you
are confused about which operations are un-doable), or if you
have been backing up through a long undo list and over-shoot
your stopping point.  Any change that is made since the undo
in question will trim the redo list.  For example if you add
ten lines, then undo three of them you could use redo to put
them back, but if you move a line on the board before performing
the redo, you will lose the ability to "redo" the three "undone" lines. 
Default:
<pre>!Shift&lt;Key&gt;r:	Redo()
</pre>

<br><dt><code>RemoveSelected()</code>
<dd>This routine removes all visible and selected objects. 
There are no defaults.

<br><dt><code>Report(Object|DrillReport)</code>
<dd>This routine pops up a dialog box describing the various
characteristics of an object (or piece of an object such as a pad or pin)
in the layout at the cursor position, or a report about all of the
drill holes in the layout. 
There are no defaults.

<br><dt><code>RouteStyle(1|2|3|4)</code>
<dd>This routine copies the sizes corresponding to the numbered route style
into the active line thicknes, via diameter, and via drill size. 
Defaults:
<pre>!Ctrl&lt;Key&gt;1: RouteStyle(1)
...
!Ctrl&lt;Key&gt;NUM_STYLES: RouteStyle(NUM_STYLES)
</pre>
The variable <code>NUM_STYLES</code> is set at compile time in
<code>globalconfig.h</code>.

<br><dt><code>Save(Layout|LayoutAs)</code>
<dt><code>Save(AllConnections|AllUnusedPins|ElementConnections)</code>
<dd>Passing <em>Layout</em> saves the layout using the file from which it was
loaded or, if it is a new layout, calls <em>Save(LayoutAs)</em> which queries
the user for a filename. 
The values: <em>AllConnections</em>, <em>AllUnusedPins</em> and
<em>ElementConnections</em> start a connection scan and save all connections,
all unused pins or the connections of a single element to a file. 
There are no defaults.

<br><dt><code>Select(All|Block|Connection|ToggleObject)</code>
<dt><code>Select(ElementByName|ObjectByName|PadByName|PinByName)</code>
<dt><code>Select(TextByName|ViaByName)</code>
<dd>Toggles either the selection flag of the object at the cross hair position
(<em>ToggleObject</em>) or selects all visible objects, all inside a
rectangle or all objects which have been found during the last connection
scan. The <em>ByName</em> functions use a regular expression search,
always case insensitive, to select the objects. 
Default:
<pre>None&lt;Btn3Down&gt;:  Select(ToggleObject)
None&lt;Btn3Down&gt;,None&lt;Btn3Motion&gt;: See resource file - this is complex
</pre>

<dt><code>SetFlag(Object|SelectElements|SelectedPins|SelectedVias|Selected,thermal|octagon|square)</code>
<dd>Sets the indicated flag.  This adds thermals, sets the flag
which indicates a pin/pad should be square, or sets the flag which
indicates a pin/pad should be octagonal.
<pre>:SetFlag(Selected,thermal)
</pre>

<br><dt><code>SetValue(Grid|LineSize|TextScale|ViaDrillingHole|ViaSize|Zoom, value)</code>
<dd>Some internal values may be changed online by this function. 
The first parameter specifies which data has to be changed. The other one
determines if the resource is set to the passed value, if <em>value</em> is
specified without sign, or increments/decrements if it is specified with
a plus or minus sign. 
The function doesn't change any existing object only the initial values of
new objects.  Use the <em>ChangeSize()</em> and <em>ChangeDrillSize()</em>
to change existing objects. 
Default:
<pre>None&lt;Key&gt;g:        SetValue(Grid, +5)
!Shift&lt;Key&gt;g:      SetValue(Grid, -5)
None&lt;Key&gt;l:        SetValue(LineSize, +5)
!Shift&lt;Key&gt;l:      SetValue(LineSize, -5)
None&lt;Key&gt;t:        SetValue(TextScale, +10)
!Shift&lt;Key&gt;t:      SetValue(TextScale, -10)
None&lt;Key&gt;v:        SetValue(ViaSize, +5)
!Shift&lt;Key&gt;v:      SetValue(ViaSize, -5)
!Mod1&lt;Key&gt;v:       SetValue(ViaDrillingHole, +5)
!Mod1 Shift&lt;Key&gt;v: SetValue(ViaDrillingHole, -5)
None&lt;Key&gt;z:        SetValue(Zoom, -1)
!Shift&lt;Key&gt;z:      SetValue(Zoom, +1)
</pre>

<br><dt><code>SwapSides()</code>
<dd>This routine changes the board side you are viewing. 
Default:
<pre>None&lt;Key&gt;Tab:      SwapSides()
</pre>

<br><dt><code>SwitchDrawingLayer(value)</code>
<dd>Makes layer numer 1..MAX_LAYER the current one. 
Default:
<pre>None&lt;Key&gt;1:        SwitchDrawingLayer(1)
...
None&lt;Key&gt;MAX_LAYER:        SwitchDrawingLayer(MAX_LAYER)
</pre>

<br><dt><code>ToggleHideName(Object|SelectedElements)</code>
<dd>Toggles whether the element's name is displayed or hidden. If it
is hidden you won't see it on the screen and it will not appear
on the silk layer when you print the layout.
<pre>None&lt;Key&gt;h:	ToggleHideName(Object)
!Shift&lt;Key&gt;h:	ToggleHideName(SelectedElements)
</pre>

<br><dt><code>ToggleVisibility(Layer)</code>
<dd>Toggles the visibility of the layer.
<pre>Mod1&lt;Key&gt;1:	ToggleVisibility(1)
Mod1&lt;Key&gt;2:	ToggleVisibility(2)
Mod1&lt;Key&gt;3:	ToggleVisibility(3)
Mod1&lt;Key&gt;4:	ToggleVisibility(4)
</pre>

<br><dt><code>Undo()</code>
<dt><code>Undo(ClearList)</code>
<dd>The unlimited undo feature of <code>Pcb</code> allows you to recover
from most operations that materially affect you work. 
Calling <em>Undo()</em> without any parameter recovers
from the last (non-undo) operation. <em>ClearList</em> is used to release the
allocated memory. <em>ClearList</em> is called whenever a new layout is started
or loaded. See also <em>Redo</em>. 
Default:
<pre>None&lt;Key&gt;u:        Undo()
!Shift Ctrl&lt;Key&gt;u: Undo(ClearList)
</pre>

<br><dt><code>Unselect(All|Block|Connection)</code>
<dd>Unselects all visible objects, all inside a rectangle or all objects which
have been found during the last connection scan. 
Default:
<pre>!Shift &lt;Btn3Down&gt;: Mode(Save) Mode(None) Unselect(Block)
!Shift &lt;Btn3Up&gt;:   Unselect(Block) Mode(Restore)
</pre>

</dl>

<p><hr>
Node:<a name="Translations">Translations</a>,
Previous:<a rel=previous href="#Actions">Actions</a>,
Up:<a rel=up href="#X11%20Interface">X11 Interface</a>
<br>

<h2>Default Translations</h2>

<p>This section covers some default translations of key and button events as
defined in the shipped default application resource file. Most of them have
already been listed in <a href="#Actions">Actions</a>. <code>Pcb</code> makes use of a nice <code>X11</code>
feature; calling several action routines for one event.

<dl>

<br><dt><code>None&lt;Key&gt;BackSpace:</code>
<br><dt><code>None&lt;key&gt;Delete:</code>
<dt><code>!Shift&lt;Key&gt;BackSpace:</code>
<dt><code>!Shift Ctrl&lt;Btn1&gt;:</code>
<dd>The object at the cursor location is removed by <em>None&lt;Key&gt;BackSpace</em> or
<em>Shift Ctrl&lt;Btn1&gt;</em> whereas <em>Shift&lt;Key&gt;BackSpace</em> also removes
all other objects that are fully-connected to the one at the cursor location.

<br><dt><code>!Mod1 Ctrl&lt;Key&gt;Left:</code>
<dt><code>!Mod1 Ctrl&lt;Key&gt;Right:</code>
<dt><code>!Mod1 Ctrl&lt;Key&gt;Up:</code>
<dt><code>!Mod1 Ctrl&lt;Key&gt;Down:</code>
<dd>Scroll one page in one of the four directions.

<br><dt><code>None&lt;Key&gt;Left:, !Shift&lt;Key&gt;Left:</code>
<dt><code>None&lt;Key&gt;Right:, !Shift&lt;Key&gt;Right:</code>
<dt><code>None&lt;Key&gt;Up:, !Shift&lt;Key&gt;Up:</code>
<dt><code>None&lt;Key&gt;Down:, !Shift&lt;Key&gt;Down:</code>
<dd>Move cross hair either one or ten points in grid.

<br><dt><code>None&lt;Key&gt;Return:</code>
<dd>Finished user input, selects the 'default' button of dialogs.

<br><dt><code>None&lt;Key&gt;Escape:</code>
<dd><em>Mode(Reset)</em>, aborts user input, selects the 'abort' button of
dialogs or resets all modes.

<br><dt><code>None&lt;Btn2Down&gt;, Btn2&lt;Motion&gt;, None&lt;Btn2Up&gt;:</code>
<dt><code>!Mod1&lt;Btn2Down&gt;, Btn2&lt;Motion&gt;, !Mod1&lt;Btn2Up&gt;:</code>
<dd>The first sequence moves the object or element name at the cursor location. 
The second one copies the objects. Copying isn't available for
element names.

</dl>

<p><hr>
Node:<a name="File%20Formats">File Formats</a>,
Next:<a rel=next href="#Library%20Creation">Library Creation</a>,
Previous:<a rel=previous href="#X11%20Interface">X11 Interface</a>,
Up:<a rel=up href="#Top">Top</a>
<br>

<h1>File Formats</h1>

<p>All files used by <code>Pcb</code> are read from the standard output of a command
or written to the standard input of one as plain seven bit <code>ASCII</code>. This
makes it possible to use any editor to change the contents of a layout file. 
It is the only way for element or font description files to be created. 
To do so you'll need to study the example files <code>example/*</code> and
<code>default_font</code> which are shipped with <code>Pcb</code>. 
For an overview refer to <a href="#Intro">Intro</a>.

<p>The following sections provide the necessary information about the syntax of
the files. 
Netlist files are not created by <code>Pcb</code>, but it does use them. For information
on the format of a netlist file see the <em>:rn</em>,
<a href="#User%20Commands">User Commands</a>. Rat lines are added on the current layer using the current
The commands described allow you to add almost any additional
functionality you may need. Examples are compressed read and write access as
well as archives. The commands themselves are defined by the resources
<em>elementCommand</em>, <em>fileCommand</em>, <em>fontCommand</em>,
<em>libraryCommand</em>, <em>libraryContentsCommand</em> and <em>saveCommand</em>. 
Note that the commands are not saved along with the data. 
It is considered an advantage to have the layout file contain all necessary
information, independent of any other files.

<p>One thing common to all files is they may include comments, newlines,
and carriage returns at any place except within quoted strings.

<ul>
<li><a href="#Basic%20Types">Basic Types</a>:             Basic types used by all data files. 
<li><a href="#Layout%20File">Layout File</a>: 
<li><a href="#Element%20File">Element File</a>: 
<li><a href="#Font%20File">Font File</a>: 
<li><a href="#Netlist%20File">Netlist File</a>: 
<li><a href="#Library%20Contents%20File">Library Contents File</a>: 
<li><a href="#Library%20File">Library File</a>: 
</ul>

<p><hr>
Node:<a name="Basic%20Types">Basic Types</a>,
Next:<a rel=next href="#Layout%20File">Layout File</a>,
Up:<a rel=up href="#File%20Formats">File Formats</a>
<br>

<h2>Basic Types</h2>

<p>Here are the basic type definitions used in the other sections of this
chapter.

<pre>Description     = Name
DeltaAngle      = Number
DrillingHole    = Number
Flags           = Number
FontPosition    = Number
Grid            = Number
GridOffsetX     = Number
GridOffsetY     = Number
Group           = GroupMember [,GroupMember]...
GroupMember     = decimal | [cs]
GroupString     = """ Group [:Group]... """
StyleString	= """ Style [:Style]... """
Height          = Number
LayerNumber     = Number
LayoutName      = Name
Name            = quoted_string
Number          = decimal | hex
PinNumber	= quoted_string
Spacing         = Number
StartAngle      = Number
SymbolID        = Number | charconst
Thickness       = Number
TextData        = quoted_string
TextFlags       = Flags
TextScale       = scale
TextX           = Number
TextY           = Number
Value           = Name
Width           = Number
X               = Number
X1              = Number
X2              = Number
Y               = Number
Y1              = Number
Y2              = Number
charconst       = "'" &lt;any character&gt; "'"
comment         = "#" {&lt;any character up to a newline&gt;}...
decimal         = [0-9]+
direction       = [0-3]
hex             = 0x[0-9a-fA-F]+
scale           = [1-&lt;positive integer&gt;]
quoted_string   = """ &lt;anything except \n and \r&gt; """
zoom            = [0-MAX]
</pre>

<p><hr>
Node:<a name="Layout%20File">Layout File</a>,
Next:<a rel=next href="#Element%20File">Element File</a>,
Previous:<a rel=previous href="#Basic%20Types">Basic Types</a>,
Up:<a rel=up href="#File%20Formats">File Formats</a>
<br>

<h2>Layout File Format</h2>

<p>The layout file describes a complete layout including symbols, vias,
elements and layers with lines, rectangles and text. This is the most
complex file of all.

<pre>File            = Header Font PCBData
Header          = PCBName [GridData] [CursorData] [PCBFlags] [Groups]
PCBName         = "PCB(" Name Width Height ")"
GridData        = "Grid(" Grid GridOffsetX GridOffsetY ")"
CursorData      = "Cursor(" X Y zoom ")"
PCBFlags        = "Flags(" Flags ")"
Groups          = "Groups(" GroupString ")"
Styles		= "Styles(" StyleString ")"
Font            = {FontData}...
FontData        = {Symbol}...
Symbol          = "Symbol(" SymbolID Spacing ")"
                      "(" {SymbolData}... ")"
SymbolData      = {SymbolLine}...
SymbolLine      = "SymbolLine(" X1 Y1 X2 Y2 Thickness ")"
PCBData         = {Via | Layer | Element}...

Via             = "Via(" X Y Thickness DrillingHole Name Flags ")"

Element         = "Element(" Flags Description LayoutName Value \
                      TextX TextY direction scale TextFlags")"
                      "(" {ElementData}... [Mark] ")"
ElementData     = {ElementLine | Pad | Pin | ElementArc }...
ElementArc      = "ElementArc(" X Y Width Height
                      StartAngle DeltaAngle Thickness ")"
ElementLine     = "ElementLine(" X1 Y1 X2 Y2 Thickness ")"
Mark            = "Mark(" X Y ")"
Pad             = "Pad(" X1 Y1 X2 Y2 Thickness Name PinNumber Flags")"
Pin             = "Pin(" X Y Thickness DrillingHole Name PinNumber Flags ")"

Layer           = "Layer(" LayerNumber Name ")"
                      "(" {LayerData}... ")"
LayerData       = {Line | Polygon | Text}...
Line            = "Line(" X1 Y1 X2 Y2 Thickness Flags")"
Arc		= "Arc(" X Y Width Height StartAngle DeltaAngle Thickness Flags")"
Polygon         = "Polygon(" Flags ")" \
                      "(" {Points}... ")"
Points          = "(" X Y ")"
Text            = "Text(" X Y direction scale TextData Flags")"
</pre>

<dl>

<br><dt><code>PCBName</code>
<dd>is used to define the layout's name which is independent of its filename. 
It is displayed in the lower left corner of the main window.

<br><dt><code>GridData</code>
<dd>is optional and is used to save the grid setting and offset which were set
at the time the layout was saved.

<br><dt><code>CursorData</code>
<dd>also is an optional parameter to save the last cursor location and zoom value. 
The real zoom factor is calculated by scale = 1:(2 power value).

<br><dt><code>PCBFlags</code>
<dd>determine how to draw lines and which name of the elements should be
displayed.
<pre>    bit 4:  do rubberband moves and rotates if set
    bit 5:  display description of elements if set
    bit 6:  display unique name of an element if set
    bit 7:  use absolute grid if set
    bit 8:  don't clip lines to 45 degrees
</pre>

<br><dt><code>Groups</code>
<dd>Layergroups are saved by using this optional parameter. The only way of
changing them is to use an editor and alter the appropriate line. The
characters <em>c,s</em> idenify the component- and solder-side for SMD
objects.

<br><dt><code>Symbol</code>
<dd>See the description of font files in this chapter.

<br><dt><code>Via</code>
<dd>Vias are always connected to all layers which also means vias are one
logical level ahead of layers. Vias are defined by position, size, name and
by some flags.
<pre>    bit 0:  always clear
    bit 1:  always set
    bit 2:  set if via was found during a connection search
    bit 4:  set if via is a hole (has no copper annulus)
    bit 5:  display the vias name
    bit 6:  via has been selected
    bit 12: set if via has octagonal shape
    Other bits have special meaning and should not be changed
    by the user.  See const.h for more information
</pre>

<br><dt><code>Element</code>
<dd>See the description of element files in this chapter.

<br><dt><code>Layer</code>
<dd>A layer is the central object from the user's point of view. It holds all
connections and all text objects. Up to 8 may be used individually. 
Its number, starting with one, and its name are read as arguments.

<dl>

<br><dt><code>Line</code>
<dd>All lines are identified by their start and endpoints together with their
thickness and some flags. They have to fit a 45 degree scheme.
<pre>    bit 2:  set if line was found during a connection search
    bit 4:  line is a rat-line
    bit 6:  line has been selected
</pre>

<br><dt><code>Polygon</code>
<dd>used to fill a larger area with <code>copper</code>. The coordinates specify the
corners. The flags are:
<pre>    bit 2:  set if polygon was found during a connection search
    bit 4:  polygon is a 1.5 style polygon that automatically clears pins
    bit 6:  polygon has been selected
</pre>

<br><dt><code>Text</code>
<dd>You may use text objects to add information to your board. An example would
be naming a connector or marking pin one of it. The position marks the
lower left corner of the string which is also a fixpoint for rotations. 
Text directions are independent to those of lines. They are counted from
zero to three with a meaning of zero to 270 degree rotations counter-clockwise. 
The scaling value is a positive integer which determines a zoom factor in
percent.
<pre>    bit 6:  the text has been selected
    bit 7:  the text is on the solder (back) side of the board
    bit 10: the text is on the silkscreen layer
</pre>

</dl>

</dl>

<p><hr>
Node:<a name="Element%20File">Element File</a>,
Next:<a rel=next href="#Font%20File">Font File</a>,
Previous:<a rel=previous href="#Layout%20File">Layout File</a>,
Up:<a rel=up href="#File%20Formats">File Formats</a>
<br>

<h2>Element File Format</h2>

<p>Element files are used to describe one component which then may be used
several times within one or more layouts. You will normally split the
file into two parts, one for the pinout and one for the package description. 
Using <code>m4</code> allows you to define pin names as macros in one file and
include a package description file which evaluates the macros. See
the resource <em>elementCommand</em> for more information. The pins (and pads)
must appear in squential order in the element file (new in 1.5) so that
pin 1 must be the first PIN(...) in the file.

<p>Doing things this way makes it possible to use one package file for several
different circuits. See the sample files <code>dil*</code>.

<p>The lowest x and y coordinates of all subobjects of an element are used
as an attachment point for the cross hair cursor of the main window.

<pre>File            = {Element}...
Element         = "Element(" Flags Description LayoutName Value \
                      TextX TextY direction scale TextFlags")"
                      "(" {ElementData}... [Mark] ")"
ElementData     = {ElementLine | Pad | Pin | ElementArc }...
ElementArc      = "ElementArc(" X Y Width Height
                      StartAngle DeltaAngle Thickness ")"
ElementLine     = "ElementLine(" X1 Y1 X2 Y2 Thickness ")"
Mark            = "Mark(" X Y ")"
Pad             = "Pad(" X1 Y1 X2 Y2 Thickness Name PinNumber Flags ")"
Pin             = "Pin(" X Y Thickness DrillingHole Name PinNumber Flags ")"
</pre>

<dl>

<br><dt><code>Element</code>
<dd>Objects of type element are determined by flags,  some names, a canonical
and a layout name as well as a value. Additional fields are text position,
their direction counted from zero to three (n * 90 degrees counter-clockwise)
and element data.

<dl>

<br><dt><code>Flags</code>
<dd>The flag field determines the state of an element. 
The bit values are:
<pre>    bit 4:  the element name is hidden
    bit 6:  element has been selected
    bit 7:  element is located on the solder side
</pre>

<br><dt><code>TextFlags</code>
<dt><code>scale</code>
<dt><code>direction</code>
<dd>See the description of text object earlier in this chapter.

<br><dt><code>ElementLine</code>
<dd>A line is defined by its start and end points and by its size, or width.

<br><dt><code>ElementArc</code>
<dd>Defines an arc by its center, width, height, startangle, its length in
degrees and its size. Remember the y axis on the screen grows downwards.

<br><dt><code>Mark</code>
<dd>is just a hint to make positioning easier. The cross hair will be positioned
here. Its center is passed as the two arguments.

<br><dt><code>Pad</code>
<dd>A pad is very similar to a line except it may not be disconnected from
its element and it has an associated name. 
Is is defined by two end point position, size, name and by some flags.
<pre>    bit 2:  set if pad was found during a connection search
    bit 5:  display the pads name
    bit 6:  pad has been selected
    bit 7:  pad is located on the solder side
</pre>

<br><dt><code>Pin</code>
<dd>A pin is very similar to a via except it may not be disconnected from
its element.
<pre>    bit 0:  always set
    bit 1:  always clear
    bit 2:  set if pin was found during a connection search
    bit 3:  set if pin is only a mounting hole (no copper annulus)
    bit 5:  display the pins name
    bit 6:  pin has been selected
    bit 8:  pin is drawn as a square
    bit 12: set if pin is drawn with an octagonal shape
</pre>

</dl>

</dl>

<p><hr>
Node:<a name="Font%20File">Font File</a>,
Next:<a rel=next href="#Netlist%20File">Netlist File</a>,
Previous:<a rel=previous href="#Element%20File">Element File</a>,
Up:<a rel=up href="#File%20Formats">File Formats</a>
<br>

<h2>Font File Format</h2>

<p>A number of user defined symbols are called a font. There is only one per
layout. All symbols are made of lines. See the file <code>default_font</code>
as an example.

<p>The lowest x and y coordinates of all lines of a font are transformed to (0,0).

<pre>File            = Font
Font            = {FontData}...
FontData        = {Symbol}...
Symbol          = "Symbol(" SymbolID FontPosition ")"
                      "(" {SymbolData}... ")"
SymbolData      = {SymbolLine}...
</pre>

<dl>

<br><dt><code>Symbol</code>
<dd>The two arguments are the <code>ASCII</code> code of the symbol and its distance to
the next symbol. Undefined symbols are drawn as filled rectangles. 
The <code>ASCII</code> code may be passed as a character constant or as a hexadecimal
value.

<dl>
<dt><code>SymbolLine</code>
<dd>The symbol data itself is made up of several entries
of type <em>SymbolLine</em>. 
</dl>

</dl>

<p><hr>
Node:<a name="Netlist%20File">Netlist File</a>,
Next:<a rel=next href="#Library%20Contents%20File">Library Contents File</a>,
Previous:<a rel=previous href="#Font%20File">Font File</a>,
Up:<a rel=up href="#File%20Formats">File Formats</a>
<br>

<h2>Netlist File Format</h2>

<p>Netlists read by <code>Pcb</code> must have this simple text form:

<pre>netname [style] NAME-PINNUM NAME2-PINNUM2 NAME3-PINNUM3 ... [\]
</pre>

<br>for each net on the layout.<br>
<p>where "netname" is the name of the net which must be unique for each
net, [style] is an optional route-style name,
NAME is the layout-name name given to an element,
and PINNUM is the (usually numeric)
pin number of the element that connects to the net
(for details on pin numbering see <a href="#Element%20Objects">Element Objects</a>). 
Spaces or tabs separate the fields. 
If the line ends with a "\" the
net continues on the next line and the "\" is treated exactly as if it
were a space.  If a NAME ends with a lower-case letter,
all lower-case letters are stripped from the end of the NAME to determine the
matching layout-name name.  For example:

<pre>     Data U1-3 U2abc-4 FLOP1a-7 Uabc3-A9
</pre>

<p>specifies that the net called "Data" should have
pin 3 of U1 connected to pin 4 of U2, to pin 7 of
FLOP1 and to pin A9 of Uabc3.  Note that element name and
pin number strings are case-sensitive. 
It is up to you to name the elements so that their layout-name names
agrees with the netlist.

<p><hr>
Node:<a name="Library%20Contents%20File">Library Contents File</a>,
Next:<a rel=next href="#Library%20File">Library File</a>,
Previous:<a rel=previous href="#Netlist%20File">Netlist File</a>,
Up:<a rel=up href="#File%20Formats">File Formats</a>
<br>

<h2>Library Contents File Format</h2>

<p>There is nothing like a special library format. The ones that have been
introduced in 1.4.1 just use some nice (and time consuming) fetures of GNU
<code>m4</code>. The only predefined format is the one of the contents file
which is read during startup. It is made up of two basic line types:

<pre>menu entry      = "TYPE="name
contents line   = template":"package":"value":"description
name            = String
template        = String
package         = String
value           = String
description     = String
String          = &lt;anything except ":", "\n" and "\r"&gt;
</pre>

<p>No leading whitespaces or comments are allowed in this file. If you need
either one, define a command that removes them before loading. Have a look
to the <em>libraryContentsCommand</em> resource.

<p>The menu entry will appear in the selection menu at the top and of the
library window.

<p><hr>
Node:<a name="Library%20File">Library File</a>,
Previous:<a rel=previous href="#Library%20Contents%20File">Library Contents File</a>,
Up:<a rel=up href="#File%20Formats">File Formats</a>
<br>

<h2>Library File Format</h2>

<p>This section provides an overview about the existing <code>m4</code> definitions
of the elements. There are basically two different types of files. One
to define element specific data like the pinout, package and so on, the
other to define the values. For example the static RAM circuits 43256 and
62256 are very similar. They therefore share a common definition in the
macro file but are defined with two different value labels.

<p>The macro file entry:
<pre>define(`Description_43256_dil', `SRAM 32Kx8')
define(`Param1_43256_dil', 28)
define(`Param2_43256_dil', 600)
define(`PinList_43256_dil', ``pin1', `pin2', ...')
</pre>

<p>And the list file:
<pre>43256_dil:N:43256:62256
</pre>

<p>The macro must define a description, the pin list and up to two additional
parameters that are passed to the package definitions. The first one is
the number of pins whereas the second one defines for example the width
of a package.

<p>It is very important to select a unique identifier for each macro. In
the example this would be <em>43256_dil</em> which is also the templates name. 
It is required by some low-level macros that
<em>Description_, Param1_, Param2_</em> and <em>PinList_</em> are prepended.

<p>The list file uses a syntax:
<pre>template:package:value[:more values]
</pre>

<p>This means that the shown example will create two element entries with the
sam package and pinout but with different names.

<p>A number of packages are defined in <code>common.m4</code>. Included are:

<pre>DIL packages with suffix D, DW, J, JD, JG, N, NT, P
PLCC
TO3
generic connectors
DIN 41.612 connectors
zick-zack (SD suffix)
15 pin multiwatt
</pre>

<p>If you are going to start your own library please take care about <code>m4</code>
functions. Be aware of quoting and so on and, most important check your
additional entry by calling the macro:

<pre>CreateObject(`template', `value', `package suffix')
</pre>

<p>If quoting is incorrect an endless loop may occur (broken by a out-of-memory
message).

<p>The scripts in the <code>lib</code> directory handle the creation of libraries
as well as of their contents files. Querying is also supported.

<p>I know quite well that this description of the library implementation is
not what some out there expect. But in my opinion it's much more useful to
look at the comments and follow the macros step by step.

<p><hr>
Node:<a name="Library%20Creation">Library Creation</a>,
Next:<a rel=next href="#Schematic%20Frontends">Schematic Frontends</a>,
Previous:<a rel=previous href="#File%20Formats">File Formats</a>,
Up:<a rel=up href="#Top">Top</a>
<br>

<h1>Library Creation</h1>

<p>This chapter provides a detailed look at how footprint libraries are
created and used.  The chapter is split into two section, the first
section covers the "old" style libraries which use the <code>m4</code> macro
processor and the second section covers the "new" style libraries.

<p>Despite the names "old" and "new", both styles of libraries are useful
and the "old" style should not be discounted because of its name.  The
advantage of the old style libraries is that one can define a family of
footprints, say a DIP package, and then quickly produce all the members
of that family.  Because the individual packages make use of a base
definition, corrections made to the base definition propagate to all the
members of a family.  The primary drawback to using this library
approach is that the effort to create a single footprint is more than a
graphical interface and may take even longer if the user has not used
the <code>m4</code> macro language previously.

<p>The new style of footprint libraries stores each footprint in its own
file.  The footprints are created graphically by placing pads and then
converting a group of pads to a component.  This library method has the
advantage of being quick to learn and it is easily to build single
footprints quickly.  If you are building a family of parts, however, the
additional effort in creating each one individually makes this approach
undesireable.  In addition, creating a part with a large pin count
can be quite tedious when done by hand.

<h2>Old Style (m4) Libraries</h2>

<p>The old style libraries for pcb use the <code>m4</code> macro processor to
allow the definition of a family of parts.  There are several files
associated with the old style library.  The file <code>common.m4</code> is the
top level file associated with the library.  <code>common.m4</code> defines a
few utility macros which are used by other portions of the library,
and then includes a predefined set of library files (the lines like
<code>include(geda.inc)</code>).

<h3>Overview of Oldlib Operation</h3>

<p>The big picture view of the old style library system is that the library
is simply a collection of macro definitions.  The macros are written in
the <code>m4</code> macro language.  An example of a macro and what it expands
to is the following.  One of the predefined footprints in the library
which comes with PCB is the <code>PKG_SO8</code> macro.  Note that all the
footprint macros begin with <code>PKG_</code>.  For this particular example,
<code>PKG_SO8</code> is a macro for an 8-pin small outline surface mount
packge.  All of the footprint macros take 3 arguments.  The first is the
canonical name of the footprint on the board.  In this case "SO8" is an
appropriate name.  The second argument is the reference designator on
the board such as "U1" or "U23".  The third and final argument is the
value.  For an integrated circuit this is usually the part number such
as "MAX4107" or "78L05" and for a component such as a resistor or
capacitor it is the resistance or capacitance.  The complete call to the
macro in our example is <code>PKG_SO8(SO8, U1, MAX4107)</code>.  When
processed by <code>m4</code> using the macros defined in the PCB library, this
macro expands to
<pre>Element(0x00 "SO8" "U1" "MAX4107" 146 50 3 100 0x00)
(
        Pad(10 25 38 25 20 "1" 0x00)
        Pad(10 75 38 75 20 "2" 0x100)
        Pad(10 125 38 125 20 "3" 0x100)
        Pad(10 175 38 175 20 "4" 0x100)
        Pad(214 175 242 175 20 "5" 0x100)
        Pad(214 125 242 125 20 "6" 0x100)
        Pad(214 75 242 75 20 "7" 0x100)
        Pad(214 25 242 25 20 "8" 0x100)
        ElementLine(0 0 151 0 10)
        ElementArc(126 0 25 25 0 180 10)
        ElementLine(101 0 252 0 10)
        ElementLine(252 0 252 200 10)
        ElementLine(252 200 0 200 10)
        ElementLine(0 200 0 0 10)
        Mark(29 25)
)
</pre>
which is the actual definition of the footprint that the PCB program
works with.  As a user of PCB the only time you will need or want to run
<code>m4</code> directly is when you are debugging a new library addition.  In
normal operation, the calls to <code>m4</code> are made by helper scripts that
come with PCB.

<p>Tools such as <code>gsch2pcb</code> (used to interface the gEDA schematic
capture program to PCB layout) will call <code>m4</code> to produce an initial
PCB layout that includes all the components on a schematic.  In
addition, when manually instantiating parts from within PCB, <code>m4</code>
will be called by PCB's helper scripts to produce the footprints.

<h3>The Library Scripts</h3>

<p>There are several scripts that are used for processing the m4
libraries.  This section briefly describes these scripts and details how
they are used by PCB.

<h4>Scripts Used During Compilation</h4>

<p>The scripts described in this section are used during compilation of
PCB.  They are run automatically by the build system, but are described
here to help document the complete library processing that occurs. 
During the build of PCB, the following actions are taken.  The
<code>CreateLibrary.sh</code> script is run to produce an M4 "frozen file". 
This frozen file is simply a partially processed M4 input file which can
be loaded by M4 more quickly than the original input file.

<p>A typical call to <code>CreateLibrary.sh</code> used during the compilation of
PCB is:
<pre>./CreateLibrary.sh -I . pcblib ./common.m4 TTL_74xx_DIL.m4
connector.m4 crystal.m4 generic.m4 genericsmt.m4 gtag.m4
jerry.m4 linear.m4 logic.m4 lsi.m4 memory.m4 optical.m4 pci.m4
resistor_0.25W.m4 resistor_adjust.m4 resistor_array.m4
texas_inst_amplifier.m4 texas_inst_voltage_reg.m4
transistor.m4 geda.m4
</pre>
The <code>-I .</code> says to search in the current directory for the
<code>.m4</code> files.  The output frozen file is <code>pcblib</code>.  The main
<code>common.m4</code> file is listed as well as all of the <code>*.m4</code> files
which define the components in the library.

<p>In addition, a library contents file is created during the build with
the <code>CreateLibraryContents.sh</code> script. 
A typical call to <code>CreateLibrary.sh</code> used during the compilation of
PCB is:
<pre>./CreateLibraryContents.sh -I . ./common.m4 TTL_74xx_DIL.list
connector.list crystal.list generic.list genericsmt.list gtag.list
jerry.list linear.list logic.list lsi.list memory.list optical.list
pci.list resistor_0.25W.list resistor_adjust.list resistor_array.list
texas_inst_amplifier.list texas_inst_voltage_reg.list transistor.list
geda.list &gt; pcblib.contents
</pre>

<p>The <code>pcblib.contents</code> file is used by the PCB program to define the
libraries and components which will be displayed when you bring up
the library window from within PCB.  An example of part of the
<code>pcblib.contents</code> file is:
<pre>TYPE=~TTL 74xx DIL
7400_dil:N:7400:4 dual-NAND
7401_dil:N:7401:4 dual-NAND OC
7402_dil:N:7402:4 dual-NOR
TYPE=~geda
geda_DIP6:DIP6:DIP6:Dual in-line package, narrow (300 mil)
geda_DIP8:DIP8:DIP8:Dual in-line package, narrow (300 mil)
geda_DIP14:DIP14:DIP14:Dual in-line package, narrow (300 mil)
geda_ACY300:ACY300:ACY300:Axial non-polar component,
</pre>
The <code>TYPE=</code> lines define the library name that will show up in the
library window in PCB.  The other lines define the actual components in
the library.

<h4>Scripts Used by PCB at Runtime</h4>

<p>When PCB is first executed, it makes a call to the
<code>ListLibraryContents.sh</code> script.  This script provides the PCB
program with the contents of the library contents file created when PCB
was compiled.  A typical call to <code>ListLibraryContents.sh</code> is
<pre>../lib/ListLibraryContents.sh .:/tmp/pcb-20030903/src/../lib pcblib
</pre>
This command says to search the path
<code>.:/tmp/pcb-20030903/src/../lib</code> for a file called
<code>pcblib.contents</code> (the <code>.contents</code> part is added
automatically) and display the contents of the file. 
PCB parses this output and generates the library window entries.

<p>When you pick a library component from the library window, PCB calls the
<code>QueryLibrary.sh</code> script to actually pull the footprint into the
layout.  For example, when the ACY300 component is selected from the
<code>~geda</code> library, the generated call may be:

<pre>/tmp/pcb-20030903/src/../lib/QueryLibrary.sh
.:/tmp/pcb-20030903/src/../lib pcblib geda_ACY300 ACY300
ACY300
</pre>
If you were to run this command by hand you would see the PCB code for
the element:
<pre>Element(0x00 "Axial non-polar component," "" "ACY300" 245 70 0 100 0x00)
(
        Pin(0 25 50 20 "1" 0x101)
        Pin(300 25 50 20 "2" 0x01)

        ElementLine(0 25 75 25 10)
        ElementLine(225 25 300 25 10)

        ElementLine(75 0 225 0 10)
        ElementLine(225 0 225 50 10)
        ElementLine(225 50 75 50 10)
        ElementLine(75 50 75 0 10)

#       ElementArc(X1 Y 50 50 270 180 10)
#       ElementArc(X2 Y 50 50 90 180 10)

        Mark(75 25)
)
</pre>

<h3>Creating an Oldlib Footprint</h3>

<p>This section provides a complete example of defining a family of
footprints using the M4 style library.  As a vehicle for this example, a
family of footprints for surface mount resistors and capacitors will be
developed.   The file <code>example.inc</code> should have been installed on
your system as <code>$prefix/share/examples/oldlib/example.inc</code> where
<code>$prefix</code> is often times <code>/usr/local</code>.

<p>The <code>example.inc</code> file defines a macro called
<code>COMMON_PKG_RCSMT</code> which is a generic definition for a surface
mount footprint with two identical, rectangular pads.  This macro will
be called with different parameters to fill out the family of parts. 
The arguments to the <code>COMMON_PKG_RCSMT</code> are:
<pre># -------------------------------------------------------------------
# the definition for suface mount resistors and capacitors
# $1: canonical name
# $2: name on PCB
# $3: value
# $4: pad width   (in direction perpendicular to part)
# $5: pad length  (in direction parallel with part)
# $6: pad spacing (center to center)
# $7: distance from edge of pad to silk (in direction
#     perpendicular to part)
# $8: distance from edge of pad to silk (in direction parallel
#     with part)
# $9: Set to "no" to skip silk screen on the sides of the part
</pre>

<pre>define(`COMMON_PKG_RCSMT',
	`define(`XMIN', `eval( -1*`$6'/2 - `$5'/2 - `$8')')
	define(`XMAX', `eval(  `$6'/2 + `$5'/2 + `$8')')
	define(`YMIN', `eval(-1*`$4'/2 - `$7')')
	define(`YMAX', `eval(   `$4'/2 + `$7')')
Element(0x00 "$1" "$2" "$3" eval(XMIN+20) eval(YMAX+20) 0 100 0x00)
(
	ifelse(0, eval($4&gt;$5),
	# Pads which have the perpendicular pad dimension less
	# than or equal to the parallel pad dimension
	Pad(eval(-1*(   $6 + $5 - $4)/2) 0
            eval((-1*$6 + $5 - $4)/2) 0 eval($4) "1" 0x100)
	Pad(eval(-1*(-1*$6 + $5 - $4)/2) 0
            eval((   $6 + $5 - $4)/2) 0 eval($4) "2" 0x100)
        ,
	# Pads which have the perpendicular pad dimension greater
	# than or equal to the parallel pad dimension
 	Pad(eval(-1*$6/2) eval(-1*($4 - $5)/2)
            eval(-1*$6/2)  eval(($4 - $5)/2) eval($5) "1" 0x100)
 	Pad(eval(   $6/2) eval(-1*($4 - $5)/2)
            eval(   $6/2)  eval(($4 - $5)/2) eval($5) "2" 0x100)
	)

	# silk screen
	# ends
	ElementLine(XMIN YMIN XMIN YMAX 10)
	ElementLine(XMAX YMAX XMAX YMIN 10)
	# sides
ifelse($9,"no",
	#skip side silk
	,
	ElementLine(XMIN YMIN XMAX YMIN 10)
	ElementLine(XMAX YMAX XMIN YMAX 10)
)
	Mark(0 0)
)')
</pre>
Note that the part has been defined with the mark located at
<code>(0,0)</code> and that the pads have been placed with the mark at the
common centroid of the footprint.  While not a requirement, this is
highly desireable when developing a library that will need to interface
with a pick and place machine used for factory assembly of a board.

<p>The final part of <code>example.inc</code> defines particular versions of the
generic footprint we have created.  These particular versions correspond
to various industry standard package sizes.
<pre># 0402 package
#
# 30x30 mil pad, 15 mil metal-metal spacing=&gt;
# 15 + 15 + 15 = 45 center-to-center
define(`PKG_RC0402',
  `COMMON_PKG_RCSMT(`$1', `$2', `$3', 30, 30, 45, 0, 10, "no")')

# 0603 package
#
# 40x40 mil pad, 30 mil metal-metal spacing=&gt;
#  30 + 20 + 20 = 70 center-to-center
define(`PKG_RC0603',
  `COMMON_PKG_RCSMT(`$1', `$2', `$3', 40, 40, 70, 10, 10)')

# 1206 package
#
# 40x60 mil pad, 90 mil metal-metal spacing=&gt;
#  90 + 20 + 20 = 130 center-to-center
define(`PKG_RC1206',
  `COMMON_PKG_RCSMT(`$1', `$2', `$3', 60, 40, 130, 10, 10)')
</pre>

<p>At this point, the <code>example.inc</code> file could be used by third party
tools such as <code>gsch2pcb</code>.  However to fully integrate our
footprints into PCB we need to create the <code>example.m4</code> and
<code>example.list</code> files.  The <code>example.m4</code> file defines
descriptions for the new footprints.
<pre>define(`Description_my_RC0402',
  ``Standard SMT resistor/capacitor (0402)'')
define(`Description_my_RC0603',
  ``Standard SMT resistor/capacitor (0603)'')
define(`Description_my_RC1206',
  ``Standard SMT resistor/capacitor (1206)'')
</pre>
Finally we need to create the <code>example.list</code> file.
<pre>my_RC0402:RC0402:RES0402
my_RC0402:RC0402:CAP0402
my_RC0603:RC0603:RES0603
my_RC0603:RC0603:CAP0603
my_RC1206:RC1206:RES1206
my_RC1206:RC1206:CAP1206
</pre>
The first field in the list file has the name corresponding to the
Description definitions in <code>example.m4</code>.  The second field is the
template name which corresponds to the macros <code>PKG_*</code> we defined in
<code>example.inc</code> with the leading <code>PKG_</code> removed.  It is the
second field which controls what footprint will actually appear on the
board.  The final
field is the name of the part type on the board.  The first line in our
<code>example.list</code> file will produce a menu entry in the library window
that reads:
<pre>CAP0402, Standard SMT resistor/capacitor (0402)
</pre>
The <code>CAP0402</code> portion comes directly from the third field in
<code>example.list</code> and the longer description comes from descriptions
macros in <code>example.m4</code>.  Please note that any extra white space
at the end of a line in the <code>.list</code> files will cause them to
not work properly.

<h3>Troubleshooting Old Style Libraries</h3>

<p>A powerful technique to help debug problems with libraries is to invoke
the <code>m4</code> processor directly.  This approach will provide error
output which is not visible from within PCB.  The following example
shows how one might try to debug an 8 pin small outline (SO8) package.  The
macro name for the package is PKG_SO8.  In this example, the
canonical name that is to be associated with the part is SO8, the
reference designator is U1, and the value is MAX4107 (the part number).

<pre>echo "PKG_SO8(SO8, U1, MAX4107)" | \
   gm4 common.m4 - | \
   awk '/^[ \t]*$/ {next} {print}' | \
   more
</pre>
The <code>awk</code> call simply removes blank lines which make the output
hard to read.

<p>For this particular example, the output is:
<pre>Element(0x00 "SO8" "U1" "MAX4107" 146 50 3 100 0x00)
(
        Pad(10 25 38 25 20 "1" 0x00)
        Pad(10 75 38 75 20 "2" 0x100)
        Pad(10 125 38 125 20 "3" 0x100)
        Pad(10 175 38 175 20 "4" 0x100)
        Pad(214 175 242 175 20 "5" 0x100)
        Pad(214 125 242 125 20 "6" 0x100)
        Pad(214 75 242 75 20 "7" 0x100)
        Pad(214 25 242 25 20 "8" 0x100)
        ElementLine(0 0 151 0 10)
        ElementArc(126 0 25 25 0 180 10)
        ElementLine(101 0 252 0 10)
        ElementLine(252 0 252 200 10)
        ElementLine(252 200 0 200 10)
        ElementLine(0 200 0 0 10)
        Mark(29 25)
)
</pre>

<h2>New Style Libraries</h2>

<p>Footprints for the new style library are created graphically using the
PCB program.  A single footprint is saved in each file.

<h3>Creating Newlib Footprints</h3>

<p>To create
<ol type=1 start=1>
</p><li>Start PCB with an empty layout. 
<li>Make the component layer active. 
<li>For a leaded part, select the via tool and place vias where the
pads for the part should go.  For surface mount pads, draw line
segments.  Note that until the footprint is completed, the surface
mount pads will remain rounded.  Currently a rectangle or polygon
may not be used as a pad. 
<li>For each via and line segment which will become a pad, select it,
right-click to bring up the popup menu and choose "edit name".  Enter
the pin number and press enter.  Alternatively, you can use the "n"
hotkey to activate the rename command. 
<li>Make the silk layer active. 
<li>Using the line and arc tools, draw a silk screen outline for the
part. 
<li>Using the selection tool, select all of the pins and silk screen
for the part. 
<li>Place the pointer above the reference point for the part.  This is
typically the common centroid.  Keeping the pointer there, right-click
to bring up the pop-up menu and choose "convert
selection to element". 
<li>Under the buffer menu, choose "save buffer elements to file" to
save the new footprint to a file.
</ol>

<h3>Modifying Newlib Footprints</h3>

<ol type=1 start=1>
<li>In the PCB program, instantiate the footprint you wish to modify. 
<li>Using the selection tool, select the footprint. 
<li>Under the buffer menu, choose "copy selection to buffer".  Now
left-click on the layout area of the PCB window and then press the ESC
key.  This copies the selected items to the buffer. 
<li>Under the buffer menu, choose "break buffer element to pieces",
"past buffer to layout", and then left-click to place the broken apart
footprint to an open area of the layout. 
<li>Make your desired modifications to the footprint and then convert
the pieces back to an element using the same procedure as when starting
from scratch on a new footprint.
</ol>

<p><hr>
Node:<a name="Schematic%20Frontends">Schematic Frontends</a>,
Next:<a rel=next href="#Installation">Installation</a>,
Previous:<a rel=previous href="#Library%20Creation">Library Creation</a>,
Up:<a rel=up href="#Top">Top</a>
<br>

<h1>Schematic Capture for PCB</h1>

<p>When designing a circuit board of any complexity, a schematic capture
frontend for the design is highly desired.  Any schematic capture
program which is able to generate a netlist in a user defined format as
well as a bill of materials can be made to work with PCB.  Currently, we
are aware of two freely available schematic capture programs which can
interface with PCB.  This chapter shows how a design can be taken from
start to finish using either of these two tools for schematic capture
and PCB for layout.

<ul>
<li><a href="#gEDA">gEDA</a>:           Interfacing with GNU EDA (gEDA). 
<li><a href="#xcircuit">xcircuit</a>:       Interfacing with xcircuit. 
</ul>

<p><hr>
Node:<a name="gEDA">gEDA</a>,
Next:<a rel=next href="#xcircuit">xcircuit</a>,
Up:<a rel=up href="#Schematic%20Frontends">Schematic Frontends</a>
<br>

<h2>gEDA</h2>

<p>This section shows how to use gEDA as the schematic capture frontend for
a PCB design.  This section is not intended to be complete documentation
on gEDA and it is assumed that the user has at least some familiarity
with the gEDA suite of programs.

<p>The basic steps in a gEDA + PCB design flow are:
<ol type=1 start=1>
</p><li>Set up project directories
<li>Set up gEDA (gschem/gnetlist) config files
<li>Set up gsch2pcb config files
<li>Capture schematics using <code>gschem</code> (part of gEDA)
<li>Create any unique PCB footprints needed for the design
<li>Generate initial PCB design using <code>gsch2pcb</code> (part of gEDA)
<li>Layout circuit board using <code>pcb</code>
<li>Make any additional schematic changes with <code>gschem</code> and
forward annotate to PCB with <code>gsch2pcb</code>
<li>Generate photoplot files (RS-274-X, also known as "Gerber") for
board vendor
</ol>

<h3>Set Up Project Directories</h3>

<p>Although not required, a typical project directory will contain the
schematics and board layout at the top level. 
Schematic symbols and circuit board footprints which are unique to this
project are stored in subdirectories.  For this example, <code>sym</code>
contains the project specific schematic symbols and <code>pkg</code> contains
the project specific footprints.  Set up the project subdirectory and
subdirectories by executing:
<pre>mkdir ~/myproj
cd ~/myproj
mkdir sym
mkdir pkg
mkdir pkg/newlib
mkdir pkg/m4
</pre>

<h3>Set Up gEDA Config Files</h3>

<p>The gEDA tools, specifically <code>gschem</code> and <code>gnetlist</code>, use
configuration files to set the search path for symbol libraries in
addition to other user preferences.  Create a file in the top level
project directory called <code>gschemrc</code>.  Add the following lines to
that file:
<pre>
;; list libraries here.  Order matters as it sets the
;; search order
(component-library "./sym")

</pre>
This sets the local search path for the schematic capture program
<code>gschem</code>.  Now the netlister, <code>gnetlist</code>, must also be
configured.  This can be done by copying the file <code>gschemrc</code> to
<code>gnetlistrc</code> by running <code>cp gschemrc gnetlistrc</code>. 
Alternatively, you can create a soft link so only a single file needs to
be updated if additional symbol paths are added.  The link is created by
running <code>ln -s gschemrc gnetlistrc</code>.

<h3>Set Up <code>gsch2pcb</code> Config Files</h3>

<p>The program <code>gsch2pcb</code>, not to be confused with the older
<code>gschem2pcb</code> script, is used to link the schematic to layout. 
<code>gsch2pcb</code> is responsible for creating the netlist used to provide
connectivity information to PCB as well creating an initial layout with
all components instantiated in the design.  Forward annotation of
schematic changes to the layout is also done using <code>gsch2pcb</code>. 
<code>gsch2pcb</code> uses a project file to set up the schematic file names,
PCB library locations, and output file names.  Create a project file
called <code>project</code> using the following as an example:
<pre>
# List all the schematics to be netlisted
# and laid out on the pc board.
schematics      first.sch second.sch third.sch

# For an output-name of foo, gsch2pcb generates files
# foo.net, foo.pcb, and foo.new.pcb.  If there is no
# output-name specified, the file names are derived from
# the first listed schematic, i.e. first.net, etc.
output-name  preamp

</pre>

<h3>Capture Schematics Using <code>gschem</code></h3>

<p>This section is fairly brief and assumes familiarity with using the
<code>gschem</code> schematic capture program.  As you are creating your
schematics, be sure to observe the following rules:
<ul>
<li>Make sure that each component in the schematic has a
<code>footprint</code> attribute that corresponds to a footprint in the PCB
library or a footprint you plan on creating. 
<li>Make sure all reference designators are unique.  One way to ensure
this is to run the <code>refdes_renum</code> script (part of gEDA) after the
schematics are created. 
</ul>

<h3>Create Any Unique PCB Footprints</h3>

<p>Create the new footprints you design needs using either the m4 style or
newlib style of PCB libraries.  Refer to chapter ? for details on this
process.  For m4 style footprints, store them in the <code>pkg/m4</code>
subdirectory and for newlib footprints, store them in the
<code>pkg/newlib</code> subdirectory.

<h3>Generate Initial PCB Design Using <code>gsch2pcb</code></h3>

<p>The <code>gsch2pcb</code> program connects the schematic and layout.  It basic
operation is to call <code>gnetlist</code> to generate the connectivity
netlist that PCB used to verify connectivity and to instantiate all
elements found in the schematic to a new layout. 
The default, as of <code>gsch2pcb</code> version 0.9,  is to use any found  m4
style parts first and then search for newlib style if no old style part
was found.  By using the <code>--use-files</code> or <code>-f</code> flag to <code>gsch2pcb</code>
priority is given to newlib style parts even if m4 style are found.  You
may wish to verify this in the <code>gsch2pcb</code> documentation in case
this changes in the future. 
To start your layout,
run <code>gsch2pcb project</code> where <code>project</code> is the project file
created previously.  This will create a new netlist file,
<code>preamp.net</code>, and a new layout file, <code>preamp.pcb</code>.

<h3>Layout Circuit Board</h3>

<p>Run PCB on the new layout by running <code>pcb preamp.pcb</code>. 
Load the netlist file by selecting "load netlist file" from the "file"
menu.  In the file selection dialog box, choose <code>preamp.net</code>.  This
loads connectivity information into PCB.

<p>Using the selection tool, grab and move apart the various footprints
with the middle mouse button.  Once the parts are moved apart from each
other, choose "optimize rats-nest" from the "Connects" menu.  This menu
choice will display and optimize the rats nest.  Use the rats nest to
help guide placement of the parts.  You may wish to re-run the "optimize
rats-nest" command after moving parts around.

<p>After the placement is complete, use the line tool to add traces to the
board.  As traces are added, the corresponding rats line will disappear.

<h2>Forward Annotation of Schematic Changes</h2>

<p>If schematic changes are made after the layout has started,
<code>gsch2pcb</code> can be used to forward annotate these changes to the
layout.  To forward annotate schematic changes, run <code>gsch2pcb
project</code>.  This command will create the files <code>preamp.new.pcb</code>,
<code>preamp.net</code>, and modify the file <code>preamp.pcb</code>.  The
modifications to <code>preamp.pcb</code> include forward annotation of
schematic component value changes, adds any new components, and removes
any deleted components.

<h3>Generate Photoplot Files (RS-274-X)</h3>

<p>After the layout is complete, choose "edit layer-groupings" from the
"Settings" menu.  The LayerGroups form lets you specify which layers
will appear in each output layer group.  For example, in the default
form, layer group 1 has "component" and "component side" in it.  The
output file <code>1.grb</code> if DOS file names are used, or
<code>somename_group1.grb</code> if long file names are used will contain the
"component" and "component side" layers in it.  Usually the defaults are
sufficient, but this form is still a useful reference.

<p>Choose "print layout..." from the "File" menu.  In the print dialog box,
select "Gerber/RS-274X" for the device
driver.  Select the "outline", "alignment", and "drillhelper" options. 
To get DOS compatible file names, select the "DOS (8.3) names" option,
otherwise enter "preamp" for the filename.  Press "OK".

<p>The following output files should have been created in the project directory. 
The names in parentheses correspond to the DOS compatible output file names.
<dl>
<dt><code>preamp_componentsilk.grb (csilk.grb)</code>
<dd>Top side silk screen. 
<br><dt><code>preamp_componentmask.grb (cmask.grb)</code>
<dd>Top side soldermask relief. 
<br><dt><code>preamp_group1.grb (1.grb)</code>
<dd>Top copper. 
<br><dt><code>preamp_soldermask.grb (smask.grb)</code>
<dd>Bottom side soldermask relief. 
<br><dt><code>preamp_group2.grb (2.grb)</code>
<dd>Bottom Copper. 
<br><dt><code>preamp_fab.grb (fab.grb)</code>
<dd>Fabrication drawing.  Also known as the drill drawing.  This drawing is
used for reference by the board vendor but is not directly used in the
fabrication process. 
<br><dt><code>preamp_plated-drill.grb (pdrill.grb)</code>
<dd>The extension <code>.grb</code> is a bit misleading as this file is actually
the Numeric Control Drill (NCD) file and not a RS-274X format file. 
</dl>

<p><hr>
Node:<a name="xcircuit">xcircuit</a>,
Previous:<a rel=previous href="#gEDA">gEDA</a>,
Up:<a rel=up href="#Schematic%20Frontends">Schematic Frontends</a>
<br>

<h2>xcircuit</h2>

<p>If anyone cares to contribute this section, it will get added.  Please
submit changes to the bug tracking system at the sourceforge project
page for PCB which can be found from the PCB homepage at
&lt;<code>http://pcb.sourceforge.net</code>&gt;.

<p><hr>
Node:<a name="Installation">Installation</a>,
Next:<a rel=next href="#Custom%20Menus">Custom Menus</a>,
Previous:<a rel=previous href="#Schematic%20Frontends">Schematic Frontends</a>,
Up:<a rel=up href="#Top">Top</a>
<br>

<h1>Installation and Troubleshooting</h1>

<p>Compiling and installing the package should be straightforward. If any problems
occur, please contact the author <a href="mailto:Thomas.Nau@rz.uni-ulm.de">Thomas.Nau@rz.uni-ulm.de</a>, or the
current maintainer <a href="mailto:haceaton@aplcomm.jhuapl.edu">haceaton@aplcomm.jhuapl.edu</a> to find
a solution and include it into the next release.

<ul>
<li><a href="#compiling">compiling</a>:      Compiling and installing. 
<li><a href="#problems">problems</a>:       Troubleshooting. 
</ul>

<p><hr>
Node:<a name="compiling">compiling</a>,
Next:<a rel=next href="#problems">problems</a>,
Up:<a rel=up href="#Installation">Installation</a>
<br>

<h2>Compiling and Installing</h2>

<p>This section covers the steps which are necessary to compile the package.

<ul>
<li><a href="#quickstart">quickstart</a>:                  Quick start. 
<li><a href="#running%20configure">running configure</a>:           Customizing Pcb with Configure
</ul>

<p><hr>
Node:<a name="quickstart">quickstart</a>,
Next:<a rel=next href="#running%20configure">running configure</a>,
Up:<a rel=up href="#compiling">compiling</a>
<br>

<h3>Quick Start</h3>

<p>Starting with version 2.0, <code>Pcb</code> has switched to a GNU
autoconf/automake build system.  Installation of <code>Pcb</code> consists of
three steps:  configuration, building, and installing. 
In a typical installation, these steps are as simple as
<pre>./configure
make
make install
</pre>

<p><hr>
Node:<a name="running%20configure">running configure</a>,
Previous:<a rel=previous href="#quickstart">quickstart</a>,
Up:<a rel=up href="#compiling">compiling</a>
<br>

<h3>Running the configure Script</h3>

<p>The <code>configure</code> script accepts all of the standard GNU configure
options.  For a complete list of configuration options, run
<code>./configure --help</code>.

<dl>
<dt><code>INFOLIBDIR</code>
<dd>must be set to the directory where your GNU info files are located.

<br><dt><code>PCBLIBDIR</code>
<dd>is the path of a directory where the font files will be installed.

<br><dt><code>DEFAULTFONT</code>
<dd>the name of the default font file.

<br><dt><code>DEFAULTLIBRARY</code>
<dd>the name of the default library.

<br><dt><code>GNUM4</code>
<dd>the name of GNUs m4 version.

<br><dt><code>BTNMOD</code>
<dd>If your window manager has already bound <em>Mod1</em> together with some
function keys you may want to change this setting. This is true for HP-VUE.

</dl>

<p>If you find things which must be changed to compile on your system,
please add the appropriate autoconf tests (if you are familiar with
that) and mail a copy to the maintainer, harry eaton,  at
<a href="mailto:haceaton@aplcomm.jhuapl.edu">haceaton@aplcomm.jhuapl.edu</a>.

<p>If you do not have the appropriate permissions you should run
<code>./pcbtest.sh</code> in the <code>src</code> directory to run <code>Pcb</code> from
the installation directory.

<p><hr>
Node:<a name="problems">problems</a>,
Previous:<a rel=previous href="#compiling">compiling</a>,
Up:<a rel=up href="#Installation">Installation</a>
<br>

<h2>Troubleshooting</h2>

<p>There are some known problems. Most of them are related to
missing parts of a standard <code>X11</code> distribution. Some others are caused by
third party applications such as <code>X</code> servers. To make this list more
complete please mail your problems and, if available, solutions to the author. 
The mail address may be found at the beginning of this chapter. 
In any case, read <a href="#X11">X11</a>.

<p>By the way, you <code>MUST HAVE AN ANSI COMPILER</code> to make <code>Pcb</code> work.

<p>Another source of problems are older versions of <code>flex</code> and <code>bison</code>. 
<code>Pcb</code> definitely works with <code>flex-2.4.7</code> and <code>bison-1.22</code> or
later. The problems will result in a <em>syntax error</em> while parsing files. 
This should only be a problem if you have modified the <code>flex</code> or
<code>bison</code> input files.

<p>The following list gives you just an idea because I'm not able to test
all <code>Pcb</code> releases on all platforms.

<ul>
<li><a href="#HP">HP</a>:               Hewlett-Packard series 700 and 800 running HP-UX 10.*
<li><a href="#Sun">Sun</a>:              Sun, Solaris 2.5
<li><a href="#SGI">SGI</a>:              SGI, IRIX 5.3 and 6.*
<li><a href="#DEC%20Alpha">DEC Alpha</a>:        DEC Alpha, DEC UNIX 3.2c and 4.0
<li><a href="#SCO">SCO</a>:              SCO Unix ODT 3.0, PC hardware
<li><a href="#Linux">Linux</a>:            Linux 0.99pl14 and later
<li><a href="#BSD">BSD</a>:              FreeBSD, NetBSD ... 
<li><a href="#X11">X11</a>:              Refers to <code>X11R4</code>, <code>X11R5</code>, and <code>OpenWindows</code>
<li><a href="#TeX%20and%20Manuals">TeX and Manuals</a>:  Problems creating the <code>pcb.dvi</code>
</ul>

<p><hr>
Node:<a name="HP">HP</a>,
Next:<a rel=next href="#Sun">Sun</a>,
Up:<a rel=up href="#problems">problems</a>
<br>

<h3>HP Series 700 and 800</h3>

<p>You have to install several <code>X11</code> include files
or, better, install a complete <code>X11R5</code> release. Hewlett-Packard doesn't
support the Athena Widgets. So the header files and libraries are missing
from the application media, but they are available as a patch. 
They also do not ship the <code>ANSI</code> compiler with the normal operating
system release so you have to buy one or use <code>GCC</code>. 
Some of the tools are available as patches.

<p>In addition, <code>Pcb</code> has been successfully tested on these platforms with
<code>HPUX 9.*, 10.*</code> running self-compiled <code>X11R5</code>.

<p><hr>
Node:<a name="Sun">Sun</a>,
Next:<a rel=next href="#SGI">SGI</a>,
Previous:<a rel=previous href="#HP">HP</a>,
Up:<a rel=up href="#problems">problems</a>
<br>

<h3>Sun SPARC architecture</h3>

<p>There are no known problems with Sun machines if they use <code>X11R5</code> instead
of <code>OpenWindows</code>. <code>Pcb</code> compiled successfully with all kinds of
SPARCstations <code>Solaris-2.[345]</code>.

<p>For problems with <code>OpenWindows</code> refer to <a href="#X11">X11</a>.

<p><hr>
Node:<a name="SGI">SGI</a>,
Next:<a rel=next href="#DEC%20Alpha">DEC Alpha</a>,
Previous:<a rel=previous href="#Sun">Sun</a>,
Up:<a rel=up href="#problems">problems</a>
<br>

<h3>Silicon Graphics</h3>

<p><code>Pcb</code> has been tested on some boxes running either <code>IRIX-4.0.5</code> or
<code>IRIX-5.3</code>. The former one uses a <code>X11R4</code> server. 
There are no problems. 
For known problems
with <code>X11R4</code>, see <a href="#X11">X11</a>.

<p><hr>
Node:<a name="DEC%20Alpha">DEC Alpha</a>,
Next:<a rel=next href="#SCO">SCO</a>,
Previous:<a rel=previous href="#SGI">SGI</a>,
Up:<a rel=up href="#problems">problems</a>
<br>

<h3>DEC Alpha</h3>

<p><code>Pcb</code> compiled and runs without problems on <code>DEC UNIX V3.2c</code>.

<p><hr>
Node:<a name="SCO">SCO</a>,
Next:<a rel=next href="#Linux">Linux</a>,
Previous:<a rel=previous href="#DEC%20Alpha">DEC Alpha</a>,
Up:<a rel=up href="#problems">problems</a>
<br>

<h3>SCO Unix</h3>

<p>John DuBois &lt;spcecdt@deeptht.armory.com&gt; wrote:
<pre><code>SCO-ODT-3.0</code> requires the latest version of tls003, the Athena
widget library (available from sosco.sco.com). The main problems
I have encountered are it core dumps fairly often, especially
while loading/dropping elements...
</pre>
I'll see what I am able to do as soon as I have access to an <code>SCO</code> system.

<p><hr>
Node:<a name="Linux">Linux</a>,
Next:<a rel=next href="#BSD">BSD</a>,
Previous:<a rel=previous href="#SCO">SCO</a>,
Up:<a rel=up href="#problems">problems</a>
<br>

<h3>Linux</h3>

<p>Since the <code>X11</code> version of <code>Pcb</code> has been developed on a Linux
system here are no known problems.

<p><hr>
Node:<a name="BSD">BSD</a>,
Next:<a rel=next href="#X11">X11</a>,
Previous:<a rel=previous href="#Linux">Linux</a>,
Up:<a rel=up href="#problems">problems</a>
<br>

<h3>FreeBSD and NetBSD</h3>

<p><code>Pcb</code> has been tested on NetBSD and works without any problems. 
You may also be able to find a NetBSD package at
&lt;<code>ftp://ftp.netbsd.org/pub/NetBSD/packages/cad/pcb/README.html</code>&gt; or a
FreeBSD port at
&lt;<code>http://www.freebsd.org/cgi/url.cgi?ports/cad/pcb/pkg-descr</code>&gt;.

<p><hr>
Node:<a name="X11">X11</a>,
Next:<a rel=next href="#TeX%20and%20Manuals">TeX and Manuals</a>,
Previous:<a rel=previous href="#BSD">BSD</a>,
Up:<a rel=up href="#problems">problems</a>
<br>

<h3>Problems related to X11</h3>

<p>There are a some problems related to <code>X11R4</code> or systems derived from
<code>X11</code> such as <code>OpenWindows</code>. See <a href="#Sun">Sun</a>. You at least have to change
all occurances of <em>baseTranslations</em> in the resource files to
<em>translations</em> if you are using a <code>X11R4</code> server. Look at the
<code>X11R5</code> <em>Intrinsics</em> manual for details.

<p>The panner widget (print dialog box) appears only in release <code>X11R5</code> and
later. It really simplifies adjusting the offsets. 
With earlier releases the printout will always appear in the center of the
page.

<p>You may have some problems in a mixed <code>X11-OpenWindows</code>
environment.

<p><code>Pcb</code> has been tested successfully with <code>X11R6</code> under Linux 1.1.59
and later.

<p><hr>
Node:<a name="TeX%20and%20Manuals">TeX and Manuals</a>,
Previous:<a rel=previous href="#X11">X11</a>,
Up:<a rel=up href="#problems">problems</a>
<br>

<h3>Problems related to TeX</h3>

<p>If your <code>TeX</code> installation complains about a missing <code>texinfo.tex</code>
file copy the one included in this release (directory <code>doc</code>
to your <code>TeX</code> macro directory. 
Note, there are probably newer versions of this file available from some
FTP sites. 
<code>TeX-3.0</code> failed, <code>TeX-3.14</code> worked just fine. Check our FTP server
<em>ftp.uni-ulm.de</em> for ready-to-print versions of the manuals.

<p><hr>
Node:<a name="Custom%20Menus">Custom Menus</a>,
Next:<a rel=next href="#Index">Index</a>,
Previous:<a rel=previous href="#Installation">Installation</a>,
Up:<a rel=up href="#Top">Top</a>
<br>

<h1>Customizing the Menus</h1>

<p>The menu system is driven off a data file that contains
<dfn>resources</dfn>.  A resource is a hierarchical description of a data
tree which, in this case, is mapped to the hierarchical menus used by
Pcb.

<ul>
<li><a href="#Resource%20Syntax">Resource Syntax</a>:           What a resource file looks like. 
<li><a href="#Menu%20Definitions">Menu Definitions</a>:          Using a resource to define a menu. 
<li><a href="#Menu%20Files%20and%20Defaults">Menu Files and Defaults</a>:   Where Pcb looks for its menu resource. 
</ul>

<p><hr>
Node:<a name="Resource%20Syntax">Resource Syntax</a>,
Next:<a rel=next href="#Menu%20Definitions">Menu Definitions</a>,
Up:<a rel=up href="#Custom%20Menus">Custom Menus</a>
<br>

<h2>Resource Syntax</h2>

<p>A resource file is a simple text file.  It contains curly braces to
group things, spaces between things, and double quotes when strings
need to include spaces.  There are four fundamental ways of adding
data to a resource.

<p>First, a string (either a single word or a quoted string with spaces,
we call both "strings" in this appendix) can be added all by itself,
to add a string resource to the current resource.  This is used, for
example, to define the string printed on a menu button.  In this
example, four strings are added to the <var>File</var> resource:

<pre>File = {
  Sample
  "longer sample"
  some text
}
</pre>

<p>Second, a named string may be added by giving two strings separated by
an equals sign.  This is used to specify X resources and a few other
optional parameters of menus, for example.  Note that a string all by
itself is thus an "unnamed" string.

<pre>{"Layer groups" foreground=red sensitive=false}
</pre>

<p>Third, an unnamed subresource may be added.  This is used to create
submenus and menu buttons.  To add a subresource, simply group other
things in curly braces.  This example describes a resource containing
one string and three subresources:

<pre>{File
  {New do_new()}
  {Save do_save()}
  {Quit do_quit()}
}
</pre>

<p>Lastly, a named subresource may be added by prefixing an unnamed
subresource with a string and an equals sign, just as when naming
strings.  This syntax is used to name the resources used for the main
menu and popup menus:

<pre>MainMenu = {
  <small>...</small>
  }
</pre>

<p>Additionally, the menu parser allows for "hooks" whereby portions of
the menu system can be programmatically created at runtime by the
application.  These hooks are invoked by a single word preceeded by an
at sign, such as this example where most of the Sizes menu is created
automatically:

<pre>{Sizes
    @sizes
    {"Adjust active sizes ..." AdjustStyle(0)}
    }
</pre>

<p><hr>
Node:<a name="Menu%20Definitions">Menu Definitions</a>,
Next:<a rel=next href="#Menu%20Files%20and%20Defaults">Menu Files and Defaults</a>,
Previous:<a rel=previous href="#Resource%20Syntax">Resource Syntax</a>,
Up:<a rel=up href="#Custom%20Menus">Custom Menus</a>
<br>

<h2>Menu Definitions</h2>

<p>To best understand this section, you should find the
<code>pcb-menu.res</code> file that your Pcb uses and refer to it for
examples (see <a href="#Menu%20Files%20and%20Defaults">Menu Files and Defaults</a>).

<p>A resource defines a menu when it meets certain semantic requirements. 
The menu heirarchy is reflected as a heirarchy of unnamed
subresources, with the first string of each subresource defining the
label used for the menu button.  A subresource that itself contains
subresources becomes a submenu, a subresource that does not becomes a
button.

<p>A submenu should only contain subresources for the buttons or submenus
within that submenu.  Two exceptions are allowed: an initial string
sets the label, and the string "-" (a single dash) will create a
separator.

<p>A button should not contain subresources, but will contain many
strings, named and unnamed.  The first member shall be an unnamed
string which is the label for the button.  Any other unnamed strings
within the button's resource will be used as actions (much like the
.Xdefaults action strings), which are functions that will be called
when the button is pressed (or popped up, or created, depending on the
action).  As a convenience, if a left parenthesis is seen, the current
"word" will continue at least until the matching right parenthesis. 
This allows you to pass strings with spaces as arguments to actions
without needing to quote the action.

<p>Named resources in button resources will be used as X resources.  Such
resources can be used to set the font, color, and spacing of buttons. 
As a convenience, "fg" can be used as an abbreviation for "foreground".

<p>Within the menu's resource file, Pcb will look for a few key named
subresources.  At the moment, the only one it looks for is one called
<code>MainMenu</code>.  This will be used for the main menu bar.  In the
future, other named subresources will be used for popup resources.

<p>Given all this, a small sample <code>pcb-menu.res</code> would be:

<pre>MainMenu = {
  {File
    {"Load layout" Load(Layout)}
    -
    {"Quit Program" Quit() fg=red font=10x20}
  }
}
</pre>

<p>Within the Pcb sources are specially crafted comments that mark all
the actions, flags, menu hooks, and whatnot that Pcb offers.  Read the
file <code>src/gather-actions</code> in the Pcb source tree for
documentation for these comments.

<p><hr>
Node:<a name="Menu%20Files%20and%20Defaults">Menu Files and Defaults</a>,
Previous:<a rel=previous href="#Menu%20Definitions">Menu Definitions</a>,
Up:<a rel=up href="#Custom%20Menus">Custom Menus</a>
<br>

<h2>Menu Files and Defaults</h2>

<p>Pcb will look for a file which defines its menus, trying the following
names:

<pre>./pcb-menu.res
$HOME/.pcb-menu.res
$PCBLIBDIR/pcb-menu.res
&lt;internal&gt;
</pre>

<p>Note that <var>pcblibdir</var> defaults to <code>/usr/local/share/pcb</code>
(hence, <code>/usr/local/share/pcb/pcb-menu.res</code>).  The
<code>&lt;internal&gt;</code> entry refers to a menu definition within the Pcb
application itself.  The master file for all this is the file
<code>src/pcb-menu.res</code> in the Pcb source tree.  This master source is
used to create the internal menu definition as well as being installed
in <code>$pcblibdir</code>.

<p>You can view the internal menu definition (the default) by running
<code>pcb</code> with the <code>-dumpmenu</code> option, like this:

<pre>pcb -dumpmenu
</pre>

<p><hr>
Node:<a name="Index">Index</a>,
Previous:<a rel=previous href="#Custom%20Menus">Custom Menus</a>,
Up:<a rel=up href="#Top">Top</a>
<br>

<h1>Index of Resources</h1>

<ul compact>
<li><code>absoluteGrid</code>: <a href="#Resources">Resources</a>
<li><code>alignmentDistance</code>: <a href="#Resources">Resources</a>
<li><code>allDirectionLines</code>: <a href="#Options">Options</a>, <a href="#Resources">Resources</a>
<li><code>backupInterval</code>: <a href="#Resources">Resources</a>, <a href="#Options">Options</a>
<li><code>bloat</code>: <a href="#Resources">Resources</a>
<li><code>BTNMOD</code>: <a href="#running%20configure">running configure</a>
<li><code>charactersPerLine</code>: <a href="#Options">Options</a>, <a href="#Resources">Resources</a>
<li><code>connectedColor</code>: <a href="#Resources">Resources</a>
<li><code>cross hairColor</code>: <a href="#Resources">Resources</a>
<li><code>default font</code>: <a href="#Options">Options</a>
<li><code>DEFAULTFONT</code>: <a href="#running%20configure">running configure</a>
<li><code>DEFAULTLIBRARY</code>: <a href="#running%20configure">running configure</a>
<li><code>elementColor</code>: <a href="#Resources">Resources</a>
<li><code>elementCommand</code>: <a href="#File%20Formats">File Formats</a>, <a href="#Resources">Resources</a>, <a href="#Options">Options</a>
<li><code>elementContentsCommand</code>: <a href="#Resources">Resources</a>
<li><code>elementPath</code>: <a href="#Resources">Resources</a>
<li><code>elementSelectedColor</code>: <a href="#Resources">Resources</a>
<li><code>fileCommand</code>: <a href="#File%20Formats">File Formats</a>, <a href="#Resources">Resources</a>, <a href="#Options">Options</a>
<li><code>filePath</code>: <a href="#Resources">Resources</a>
<li><code>fontCommand</code>: <a href="#Options">Options</a>, <a href="#File%20Formats">File Formats</a>, <a href="#Resources">Resources</a>
<li><code>fontFile</code>: <a href="#Resources">Resources</a>, <a href="#Options">Options</a>
<li><code>fontPath</code>: <a href="#Resources">Resources</a>
<li><code>GNUM4</code>: <a href="#running%20configure">running configure</a>
<li><code>grid</code>: <a href="#Resources">Resources</a>
<li><code>gridColor</code>: <a href="#Resources">Resources</a>
<li><code>INFOLIBDIR</code>: <a href="#running%20configure">running configure</a>
<li><code>invisibleObjectsColor</code>: <a href="#Resources">Resources</a>
<li><code>layerColor</code>: <a href="#Resources">Resources</a>
<li><code>layerGroups</code>: <a href="#Resources">Resources</a>, <a href="#Options">Options</a>
<li><code>layerName</code>: <a href="#Resources">Resources</a>
<li><code>layerSelectedColor</code>: <a href="#Resources">Resources</a>
<li><code>libraryCommand</code>: <a href="#Resources">Resources</a>, <a href="#Options">Options</a>, <a href="#File%20Formats">File Formats</a>
<li><code>libraryContentsCommand</code>: <a href="#File%20Formats">File Formats</a>, <a href="#Options">Options</a>
<li><code>libraryFilename</code>: <a href="#Options">Options</a>, <a href="#Resources">Resources</a>
<li><code>libraryPath</code>: <a href="#Resources">Resources</a>, <a href="#Options">Options</a>
<li><code>lineThickness</code>: <a href="#Resources">Resources</a>
<li><code>media</code>: <a href="#Resources">Resources</a>
<li><code>offLimitColor</code>: <a href="#Resources">Resources</a>
<li><code>PCBLIBDIR</code>: <a href="#running%20configure">running configure</a>
<li><code>pinColor</code>: <a href="#Resources">Resources</a>
<li><code>pinoutFont0..6</code>: <a href="#Resources">Resources</a>
<li><code>pinoutNameLength</code>: <a href="#Options">Options</a>, <a href="#Resources">Resources</a>
<li><code>pinoutOffsetX</code>: <a href="#Resources">Resources</a>
<li><code>pinoutOffsetY</code>: <a href="#Resources">Resources</a>
<li><code>pinoutTextOffsetX</code>: <a href="#Resources">Resources</a>
<li><code>pinoutTextOffsetY</code>: <a href="#Resources">Resources</a>
<li><code>pinoutZoom</code>: <a href="#Resources">Resources</a>, <a href="#Options">Options</a>
<li><code>pinSelectedColor</code>: <a href="#Resources">Resources</a>
<li><code>printCommand</code>: <a href="#Resources">Resources</a>
<li><code>raiseLogWindow</code>: <a href="#Resources">Resources</a>
<li><code>ratCommand</code>: <a href="#Resources">Resources</a>
<li><code>ratPath</code>: <a href="#Resources">Resources</a>
<li><code>resetAfterElement</code>: <a href="#Options">Options</a>, <a href="#Resources">Resources</a>
<li><code>ringBellWhenFinished</code>: <a href="#Resources">Resources</a>, <a href="#Options">Options</a>
<li><code>routeStyle</code>: <a href="#Resources">Resources</a>, <a href="#Options">Options</a>
<li><code>rubberBandMode</code>: <a href="#Resources">Resources</a>
<li><code>saveCommand</code>: <a href="#Options">Options</a>, <a href="#File%20Formats">File Formats</a>, <a href="#Resources">Resources</a>
<li><code>saveInTMP</code>: <a href="#Resources">Resources</a>, <a href="#Options">Options</a>
<li><code>saveLastCommand</code>: <a href="#Options">Options</a>, <a href="#Resources">Resources</a>
<li><code>shrink</code>: <a href="#Resources">Resources</a>
<li><code>size</code>: <a href="#Options">Options</a>, <a href="#Resources">Resources</a>
<li><code>stipplePolygons</code>: <a href="#Resources">Resources</a>
<li><code>textScale</code>: <a href="#Resources">Resources</a>
<li><code>useLogWindow</code>: <a href="#Resources">Resources</a>
<li><code>viaColor</code>: <a href="#Resources">Resources</a>
<li><code>viaDrillingHole</code>: <a href="#Resources">Resources</a>
<li><code>viaSelectedColor</code>: <a href="#Resources">Resources</a>
<li><code>viaThickness</code>: <a href="#Resources">Resources</a>
<li><code>volume</code>: <a href="#Options">Options</a>, <a href="#Resources">Resources</a>
<li><code>warnColor</code>: <a href="#Resources">Resources</a>
<li><code>zoom</code>: <a href="#Resources">Resources</a>
</ul>

<h1>Index of Actions, Commands and Options</h1>

<ul compact>
<li><code>+alldirections</code>: <a href="#Options">Options</a>
<li><code>+reset</code>: <a href="#Options">Options</a>
<li><code>+ring</code>: <a href="#Options">Options</a>
<li><code>+s</code>: <a href="#Options">Options</a>
<li><code>+save</code>: <a href="#Options">Options</a>
<li><code>-alldirections</code>: <a href="#Options">Options</a>
<li><code>-backup</code>: <a href="#Options">Options</a>
<li><code>-c</code>: <a href="#Options">Options</a>
<li><code>-copyright</code>: <a href="#Special%20Options">Special Options</a>
<li><code>-fontfile</code>: <a href="#Options">Options</a>
<li><code>-help</code>: <a href="#Special%20Options">Special Options</a>
<li><code>-lelement</code>: <a href="#Options">Options</a>
<li><code>-lfile</code>: <a href="#Options">Options</a>
<li><code>-lfont</code>: <a href="#Options">Options</a>
<li><code>-lg</code>: <a href="#Options">Options</a>
<li><code>-libname</code>: <a href="#Options">Options</a>
<li><code>-libpath</code>: <a href="#Options">Options</a>
<li><code>-llib</code>: <a href="#Options">Options</a>
<li><code>-llibcont</code>: <a href="#Options">Options</a>
<li><code>-loggeometry</code>: <a href="#Options">Options</a>
<li><code>-pnl</code>: <a href="#Options">Options</a>
<li><code>-pz</code>: <a href="#Options">Options</a>
<li><code>-reset</code>: <a href="#Options">Options</a>
<li><code>-ring</code>: <a href="#Options">Options</a>
<li><code>-rs</code>: <a href="#Options">Options</a>
<li><code>-s</code>: <a href="#Options">Options</a>
<li><code>-save</code>: <a href="#Options">Options</a>
<li><code>-sfile</code>: <a href="#Options">Options</a>
<li><code>-size</code>: <a href="#Options">Options</a>
<li><code>-v</code>: <a href="#Options">Options</a>
<li><code>-version</code>: <a href="#Special%20Options">Special Options</a>
<li><code>:actionCommand()</code>: <a href="#User%20Commands">User Commands</a>
<li><code>:l</code>: <a href="#User%20Commands">User Commands</a>
<li><code>:le</code>: <a href="#User%20Commands">User Commands</a>
<li><code>:m</code>: <a href="#User%20Commands">User Commands</a>
<li><code>:q</code>: <a href="#User%20Commands">User Commands</a>
<li><code>:rn</code>: <a href="#User%20Commands">User Commands</a>
<li><code>:s</code>: <a href="#User%20Commands">User Commands</a>
<li><code>:w[q]</code>: <a href="#User%20Commands">User Commands</a>
<li><code>AddRats()</code>: <a href="#Actions">Actions</a>
<li><code>Atomic()</code>: <a href="#Actions">Actions</a>
<li><code>Bell()</code>: <a href="#Actions">Actions</a>
<li><code>ChangeDrillSize()</code>: <a href="#Actions">Actions</a>
<li><code>ChangeFlag()</code>: <a href="#Actions">Actions</a>
<li><code>ChangeHole()</code>: <a href="#Actions">Actions</a>
<li><code>ChangeName()</code>: <a href="#Actions">Actions</a>
<li><code>ChangeOctagon()</code>: <a href="#Actions">Actions</a>
<li><code>ChangeSize()</code>: <a href="#Actions">Actions</a>
<li><code>ChangeSquare()</code>: <a href="#Actions">Actions</a>
<li><code>ClrFlag()</code>: <a href="#Actions">Actions</a>
<li><code>Command()</code>: <a href="#Actions">Actions</a>
<li><code>Connection()</code>: <a href="#Actions">Actions</a>
<li><code>DeleteRats()</code>: <a href="#Actions">Actions</a>
<li><code>Display()</code>: <a href="#Actions">Actions</a>
<li><code>DRC()</code>: <a href="#Actions">Actions</a>
<li><code>EditLayerGroups()</code>: <a href="#Actions">Actions</a>
<li><code>Load()</code>: <a href="#Actions">Actions</a>
<li><code>MarkCrosshair()</code>: <a href="#Actions">Actions</a>
<li><code>Mode()</code>: <a href="#Actions">Actions</a>
<li><code>MovePointer()</code>: <a href="#Actions">Actions</a>
<li><code>MoveToCurrentLayer()</code>: <a href="#Actions">Actions</a>
<li><code>New()</code>: <a href="#Actions">Actions</a>
<li><code>PasteBuffer()</code>: <a href="#Actions">Actions</a>
<li><code>Polygon()</code>: <a href="#Actions">Actions</a>
<li><code>Print()</code>: <a href="#Actions">Actions</a>
<li><code>Quit()</code>: <a href="#Actions">Actions</a>
<li><code>Redo()</code>: <a href="#Actions">Actions</a>
<li><code>RemoveSelected()</code>: <a href="#Actions">Actions</a>
<li><code>Report()</code>: <a href="#Actions">Actions</a>
<li><code>RouteStyle()</code>: <a href="#Actions">Actions</a>
<li><code>Save()</code>: <a href="#Actions">Actions</a>
<li><code>Select()</code>: <a href="#Actions">Actions</a>
<li><code>SetFlag()</code>: <a href="#Actions">Actions</a>
<li><code>SetValue()</code>: <a href="#Actions">Actions</a>
<li><code>SwapSides()</code>: <a href="#Actions">Actions</a>
<li><code>SwitchDrawingLayer()</code>: <a href="#Actions">Actions</a>
<li><code>ToggleHideName()</code>: <a href="#Actions">Actions</a>
<li><code>ToggleVisibility()</code>: <a href="#Actions">Actions</a>
<li><code>Undo()</code>: <a href="#Actions">Actions</a>
<li><code>Unselect()</code>: <a href="#Actions">Actions</a>
</ul>

<h1>Index of Concepts</h1>

<ul compact>
<li>/tmp: <a href="#Loading%20and%20Saving">Loading and Saving</a>, <a href="#Options">Options</a>, <a href="#Resources">Resources</a>
<li>action command: <a href="#User%20Commands">User Commands</a>
<li>actions: <a href="#Actions">Actions</a>
<li>Actions, initiating: <a href="#User%20Commands">User Commands</a>
<li>alignment: <a href="#Resources">Resources</a>
<li>alignment targets: <a href="#Printing">Printing</a>
<li>Alpha: <a href="#DEC%20Alpha">DEC Alpha</a>
<li>arc: <a href="#Arc%20Objects">Arc Objects</a>
<li>arc, an example: <a href="#Arcs">Arcs</a>
<li>architecture: <a href="#Sun">Sun</a>, <a href="#SCO">SCO</a>, <a href="#DEC%20Alpha">DEC Alpha</a>, <a href="#SGI">SGI</a>, <a href="#HP">HP</a>, <a href="#Linux">Linux</a>
<li>arrow tool: <a href="#Arrow%20Tool">Arrow Tool</a>
<li>ASCII files, format of: <a href="#File%20Formats">File Formats</a>
<li>Atari version: <a href="#History">History</a>
<li>atomic: <a href="#Actions">Actions</a>
<li>auto-router: <a href="#Menu">Menu</a>
<li>backup: <a href="#Loading%20and%20Saving">Loading and Saving</a>, <a href="#Options">Options</a>, <a href="#Resources">Resources</a>, <a href="#Options">Options</a>, <a href="#Resources">Resources</a>
<li>basic types: <a href="#Basic%20Types">Basic Types</a>
<li>bell: <a href="#Actions">Actions</a>
<li>bloat: <a href="#Resources">Resources</a>
<li>buffer, an example: <a href="#Pastebuffer">Pastebuffer</a>
<li>buffer, convert contents to element: <a href="#Elements">Elements</a>
<li>Buffer, popup menu: <a href="#Menu">Menu</a>
<li>buffer, selecting a: <a href="#Actions">Actions</a>
<li>button translations: <a href="#Actions">Actions</a>
<li>cat: <a href="#Resources">Resources</a>
<li>centering: <a href="#Actions">Actions</a>
<li>change active layer: <a href="#Layer%20Controls">Layer Controls</a>
<li>change drawing layer: <a href="#Actions">Actions</a>
<li>change object name: <a href="#Actions">Actions</a>
<li>change settings: <a href="#Actions">Actions</a>
<li>change sizes: <a href="#Actions">Actions</a>
<li>change square flag: <a href="#Actions">Actions</a>
<li>change viewing side: <a href="#Actions">Actions</a>
<li>characters per line: <a href="#Resources">Resources</a>, <a href="#Options">Options</a>
<li>clearance: <a href="#Line%20Objects">Line Objects</a>
<li>clearance, for new lines: <a href="#Menu">Menu</a>
<li>clipping lines to 45 degree: <a href="#Actions">Actions</a>, <a href="#Resources">Resources</a>
<li>clipping of lines: <a href="#Options">Options</a>
<li>closing a polygon: <a href="#Actions">Actions</a>
<li>color printout: <a href="#Printing">Printing</a>
<li>color, warning: <a href="#Resources">Resources</a>
<li>colors: <a href="#Resources">Resources</a>
<li>command-line options: <a href="#Command-Line%20Options">Command-Line Options</a>
<li>compile, how to: <a href="#compiling">compiling</a>
<li>configure: <a href="#running%20configure">running configure</a>
<li>connection, removing an: <a href="#Translations">Translations</a>
<li>connections, colors: <a href="#Resources">Resources</a>
<li>connections, creating list of: <a href="#Connection%20Lists">Connection Lists</a>
<li>connections, reseting: <a href="#Actions">Actions</a>
<li>connections, reseting after element: <a href="#Resources">Resources</a>, <a href="#Options">Options</a>
<li>connections, searching for: <a href="#Actions">Actions</a>
<li>Connects, popup menu: <a href="#Menu">Menu</a>
<li>copy an object: <a href="#Translations">Translations</a>
<li>copying objects: <a href="#Actions">Actions</a>
<li>copying, an example: <a href="#Moving%20and%20Copying">Moving and Copying</a>
<li>copyright: <a href="#Special%20Options">Special Options</a>
<li>creating objects: <a href="#Common">Common</a>
<li>cursor color: <a href="#Resources">Resources</a>
<li>cursor movements: <a href="#Actions">Actions</a>
<li>cursor position: <a href="#Actions">Actions</a>
<li>cursor steps: <a href="#Resources">Resources</a>
<li>cutting objects: <a href="#Actions">Actions</a>
<li>DEC: <a href="#DEC%20Alpha">DEC Alpha</a>
<li>default font: <a href="#Options">Options</a>, <a href="#Resources">Resources</a>
<li>default layout size: <a href="#Resources">Resources</a>
<li>default library: <a href="#Resources">Resources</a>
<li>default text scaling: <a href="#Resources">Resources</a>
<li>default translations: <a href="#Translations">Translations</a>
<li>design rule checker, invoking: <a href="#Menu">Menu</a>
<li>design rule checking: <a href="#Design%20Rule%20Checking">Design Rule Checking</a>, <a href="#Actions">Actions</a>
<li>device, selecting an output: <a href="#Printing">Printing</a>
<li>directory /tmp: <a href="#Resources">Resources</a>, <a href="#Loading%20and%20Saving">Loading and Saving</a>, <a href="#Options">Options</a>
<li>display: <a href="#Resources">Resources</a>
<li>displaying element names: <a href="#Menu">Menu</a>, <a href="#Actions">Actions</a>
<li>displaying pinout: <a href="#Actions">Actions</a>
<li>displaying status information: <a href="#Status-line%20and%20Input-field">Status-line and Input-field</a>
<li>DOS filenames: <a href="#Printing">Printing</a>
<li>drawing objects: <a href="#Drawing%20and%20Removing">Drawing and Removing</a>
<li>drc: <a href="#Resources">Resources</a>, <a href="#Actions">Actions</a>, <a href="#Design%20Rule%20Checking">Design Rule Checking</a>, <a href="#Resources">Resources</a>
<li>drill: <a href="#Actions">Actions</a>
<li>drill report: <a href="#Menu">Menu</a>
<li>drilling hole, changing of objects: <a href="#Actions">Actions</a>
<li>drilling hole, setting of initial size: <a href="#Actions">Actions</a>
<li>Edit, popup menu: <a href="#Menu">Menu</a>
<li>element name, hiding: <a href="#Actions">Actions</a>
<li>element name, removing from silk-screen: <a href="#Actions">Actions</a>
<li>element, an example: <a href="#Elements">Elements</a>
<li>element, an overview: <a href="#Element%20Objects">Element Objects</a>
<li>element, color: <a href="#Resources">Resources</a>
<li>element, command: <a href="#Resources">Resources</a>, <a href="#Options">Options</a>
<li>element, creating a new package: <a href="#Elements">Elements</a>
<li>element, display names of: <a href="#Menu">Menu</a>, <a href="#Actions">Actions</a>
<li>element, editing: <a href="#Menu">Menu</a>
<li>element, fileformat: <a href="#Element%20File">Element File</a>
<li>element, files: <a href="#Resources">Resources</a>, <a href="#Options">Options</a>, <a href="#Resources">Resources</a>
<li>element, loading to buffer: <a href="#User%20Commands">User Commands</a>
<li>element, move name of: <a href="#Translations">Translations</a>
<li>entering user commands: <a href="#User%20Commands">User Commands</a>
<li>erasing objects: <a href="#Drawing%20and%20Removing">Drawing and Removing</a>
<li>example files: <a href="#Elements">Elements</a>
<li>example of buffer handling: <a href="#Pastebuffer">Pastebuffer</a>
<li>example of connection lists: <a href="#Connection%20Lists">Connection Lists</a>
<li>example of copying: <a href="#Moving%20and%20Copying">Moving and Copying</a>
<li>example of creating an element: <a href="#Elements">Elements</a>
<li>example of element handling: <a href="#Elements">Elements</a>
<li>example of line handling: <a href="#Lines">Lines</a>
<li>example of loading: <a href="#Loading%20and%20Saving">Loading and Saving</a>
<li>example of loading an element file: <a href="#Elements">Elements</a>
<li>example of moving: <a href="#Moving%20and%20Copying">Moving and Copying</a>
<li>example of pastebuffer handling: <a href="#Pastebuffer">Pastebuffer</a>
<li>example of pin handling: <a href="#Elements">Elements</a>
<li>example of polygon handling: <a href="#Polygons">Polygons</a>
<li>example of printing: <a href="#Printing">Printing</a>
<li>example of rectangle handling: <a href="#Polygons">Polygons</a>
<li>example of saving: <a href="#Loading%20and%20Saving">Loading and Saving</a>
<li>example of text handling: <a href="#Text">Text</a>
<li>example of via handling: <a href="#Vias">Vias</a>
<li>exit: <a href="#Actions">Actions</a>, <a href="#User%20Commands">User Commands</a>
<li>file format, element data: <a href="#Element%20File">Element File</a>
<li>file format, font data: <a href="#Font%20File">Font File</a>
<li>file format, layout data: <a href="#Layout%20File">Layout File</a>
<li>file format, libraries: <a href="#Library%20File">Library File</a>
<li>file format, library contents: <a href="#Library%20Contents%20File">Library Contents File</a>
<li>file formats: <a href="#File%20Formats">File Formats</a>
<li>file formats, basic types: <a href="#Basic%20Types">Basic Types</a>
<li>file load command: <a href="#Options">Options</a>, <a href="#Resources">Resources</a>
<li>file save command: <a href="#Options">Options</a>, <a href="#Resources">Resources</a>
<li>File, popup menu: <a href="#Menu">Menu</a>
<li>flags, changing: <a href="#Actions">Actions</a>
<li>flags, clearing: <a href="#Actions">Actions</a>
<li>flags, setting: <a href="#Actions">Actions</a>
<li>font command: <a href="#Resources">Resources</a>, <a href="#Options">Options</a>
<li>font file, format of: <a href="#Font%20File">Font File</a>
<li>font files: <a href="#Resources">Resources</a>, <a href="#Options">Options</a>
<li>font, an overview: <a href="#Symbol%20Objects">Symbol Objects</a>
<li>font, used for pin names: <a href="#Resources">Resources</a>
<li>format of element files: <a href="#Element%20File">Element File</a>
<li>format of font files: <a href="#Font%20File">Font File</a>
<li>format of layout files: <a href="#Layout%20File">Layout File</a>
<li>format of libraries: <a href="#Library%20File">Library File</a>
<li>format of library contents: <a href="#Library%20Contents%20File">Library Contents File</a>
<li>FreeBSD: <a href="#BSD">BSD</a>
<li>gEDA, how to interface with: <a href="#gEDA">gEDA</a>
<li>GNU build system: <a href="#quickstart">quickstart</a>
<li>GNU configure script: <a href="#running%20configure">running configure</a>
<li>grid: <a href="#Layout%20Area">Layout Area</a>, <a href="#Resources">Resources</a>
<li>grid color: <a href="#Resources">Resources</a>
<li>grid, absolute and relative: <a href="#Actions">Actions</a>
<li>grid, alignment: <a href="#Menu">Menu</a>
<li>grid, display: <a href="#Actions">Actions</a>, <a href="#Menu">Menu</a>
<li>grid, setting of: <a href="#Actions">Actions</a>
<li>groups: <a href="#Options">Options</a>, <a href="#Resources">Resources</a>
<li>groups, editing of: <a href="#Actions">Actions</a>
<li>gschem, how to interface with: <a href="#gEDA">gEDA</a>
<li>Hewlett Packard: <a href="#HP">HP</a>
<li>hide element name: <a href="#Actions">Actions</a>
<li>how to start: <a href="#Getting%20Started">Getting Started</a>
<li>HP: <a href="#HP">HP</a>
<li>Info, popup menu: <a href="#Menu">Menu</a>
<li>information about objects: <a href="#Actions">Actions</a>
<li>input-field, position of: <a href="#Status-line%20and%20Input-field">Status-line and Input-field</a>
<li>inputfield, saving entered command-line: <a href="#Options">Options</a>, <a href="#Resources">Resources</a>
<li>inputfield, start user input: <a href="#Actions">Actions</a>
<li>install, how to: <a href="#compiling">compiling</a>
<li>key translations: <a href="#Actions">Actions</a>
<li>keyboard bell: <a href="#Options">Options</a>, <a href="#Resources">Resources</a>
<li>layer controls: <a href="#Layer%20Controls">Layer Controls</a>
<li>layer groups: <a href="#Layer%20Objects">Layer Objects</a>
<li>layer visibility, toggling: <a href="#Actions">Actions</a>
<li>layer, change active: <a href="#Actions">Actions</a>
<li>layer, name of: <a href="#Resources">Resources</a>
<li>layers, an overview: <a href="#Layer%20Objects">Layer Objects</a>
<li>layers, changing which is active: <a href="#Layer%20Controls">Layer Controls</a>
<li>layers, colors: <a href="#Resources">Resources</a>
<li>layers, editing of groups: <a href="#Actions">Actions</a>
<li>layers, groups: <a href="#Options">Options</a>, <a href="#Resources">Resources</a>
<li>layers, switching on/off: <a href="#Layer%20Controls">Layer Controls</a>
<li>layout files: <a href="#Resources">Resources</a>, <a href="#Options">Options</a>
<li>layout files, format of: <a href="#Layout%20File">Layout File</a>
<li>layout files, saving of: <a href="#User%20Commands">User Commands</a>
<li>layout objects, an overview: <a href="#Intro">Intro</a>
<li>layout size: <a href="#Options">Options</a>
<li>layout, default size of: <a href="#Resources">Resources</a>
<li>layout, loading a: <a href="#User%20Commands">User Commands</a>
<li>layout, loading to buffer: <a href="#User%20Commands">User Commands</a>
<li>layout, merging a: <a href="#User%20Commands">User Commands</a>
<li>layout, printing a: <a href="#Actions">Actions</a>
<li>layout, start a new: <a href="#Actions">Actions</a>
<li>layout-name: <a href="#Element%20Objects">Element Objects</a>, <a href="#User%20Commands">User Commands</a>
<li>length of a pin name: <a href="#Options">Options</a>, <a href="#Resources">Resources</a>
<li>length of outputline: <a href="#Options">Options</a>
<li>library accuracy: <a href="#Element%20Objects">Element Objects</a>
<li>library command: <a href="#Resources">Resources</a>, <a href="#Options">Options</a>
<li>library contents command: <a href="#Resources">Resources</a>, <a href="#Options">Options</a>
<li>library contents file, format of: <a href="#Library%20Contents%20File">Library Contents File</a>
<li>library creation: <a href="#Library%20Creation">Library Creation</a>
<li>library file, format of: <a href="#Library%20File">Library File</a>
<li>library name: <a href="#Resources">Resources</a>, <a href="#Options">Options</a>
<li>library search path: <a href="#Options">Options</a>
<li>library searchpath: <a href="#Resources">Resources</a>
<li>library window: <a href="#Library%20Window">Library Window</a>
<li>line clipping: <a href="#Options">Options</a>
<li>linelength: <a href="#Resources">Resources</a>
<li>lines, an example: <a href="#Lines">Lines</a>
<li>lines, an overview: <a href="#Line%20Objects">Line Objects</a>
<li>lines, clipping to 45 degree: <a href="#Resources">Resources</a>, <a href="#Actions">Actions</a>
<li>lines, setting of initial size: <a href="#Actions">Actions</a>
<li>lines, size: <a href="#Resources">Resources</a>
<li>Linux: <a href="#Linux">Linux</a>
<li>list of connections: <a href="#Resources">Resources</a>
<li>listing libraries: <a href="#Options">Options</a>
<li>listing library contents: <a href="#Resources">Resources</a>
<li>loading a layout to buffer: <a href="#User%20Commands">User Commands</a>
<li>loading elements: <a href="#Options">Options</a>, <a href="#Resources">Resources</a>, <a href="#Options">Options</a>, <a href="#Resources">Resources</a>
<li>loading elements to buffer: <a href="#User%20Commands">User Commands</a>
<li>loading files: <a href="#Actions">Actions</a>
<li>loading fonts: <a href="#Resources">Resources</a>, <a href="#Options">Options</a>, <a href="#Resources">Resources</a>
<li>loading layouts: <a href="#Resources">Resources</a>, <a href="#User%20Commands">User Commands</a>, <a href="#Options">Options</a>, <a href="#Resources">Resources</a>
<li>loading symbols: <a href="#Resources">Resources</a>, <a href="#Options">Options</a>, <a href="#Resources">Resources</a>
<li>loading, an example: <a href="#Loading%20and%20Saving">Loading and Saving</a>
<li>log window: <a href="#Resources">Resources</a>, <a href="#Log%20Window">Log Window</a>, <a href="#Options">Options</a>
<li>m4: <a href="#Resources">Resources</a>
<li>m4, preprocessing example files: <a href="#Elements">Elements</a>
<li>mark: <a href="#Actions">Actions</a>
<li>media: <a href="#Resources">Resources</a>
<li>media margin: <a href="#Resources">Resources</a>
<li>media, size of: <a href="#Printing">Printing</a>
<li>menus: <a href="#Menu">Menu</a>
<li>merging layouts: <a href="#User%20Commands">User Commands</a>
<li>messages: <a href="#Options">Options</a>, <a href="#Resources">Resources</a>, <a href="#Log%20Window">Log Window</a>
<li>mirroring printout: <a href="#Printing">Printing</a>
<li>mode selection: <a href="#Tool%20Selectors">Tool Selectors</a>
<li>mode, selecting of: <a href="#Actions">Actions</a>
<li>mounting holes: <a href="#Actions">Actions</a>
<li>move: <a href="#Resources">Resources</a>
<li>move an object: <a href="#Translations">Translations</a>
<li>moving objects: <a href="#Arrow%20Tool">Arrow Tool</a>
<li>moving objects to current layer: <a href="#Actions">Actions</a>
<li>moving, an example: <a href="#Moving%20and%20Copying">Moving and Copying</a>
<li>name of an element: <a href="#Actions">Actions</a>
<li>name, change an objects: <a href="#Actions">Actions</a>
<li>namelength of pins: <a href="#Resources">Resources</a>, <a href="#Options">Options</a>
<li>NetBSD: <a href="#BSD">BSD</a>
<li>netlist: <a href="#Resources">Resources</a>, <a href="#Actions">Actions</a>, <a href="#Rats%20Nest">Rats Nest</a>, <a href="#Resources">Resources</a>, <a href="#Net%20Objects">Net Objects</a>
<li>Netlist Window: <a href="#Netlist%20Window">Netlist Window</a>
<li>netlist, file format: <a href="#Netlist%20File">Netlist File</a>
<li>netlist, reading: <a href="#Netlist%20File">Netlist File</a>
<li>object report: <a href="#Menu">Menu</a>
<li>object, change name of: <a href="#Actions">Actions</a>
<li>object, changing the size of an: <a href="#Common">Common</a>
<li>object, copy an: <a href="#Translations">Translations</a>
<li>object, creating an: <a href="#Common">Common</a>
<li>object, drawing and removing: <a href="#Drawing%20and%20Removing">Drawing and Removing</a>
<li>object, move an: <a href="#Translations">Translations</a>
<li>object, removing an: <a href="#Translations">Translations</a>, <a href="#Common">Common</a>
<li>objects, moving to current layer: <a href="#Actions">Actions</a>
<li>octagonal flag, changing: <a href="#Actions">Actions</a>
<li>octagonal flag, clearing: <a href="#Actions">Actions</a>
<li>octagonal flag, setting: <a href="#Actions">Actions</a>
<li>octagonal pins and vias: <a href="#Actions">Actions</a>
<li>off limit color: <a href="#Resources">Resources</a>
<li>offset of pinnames: <a href="#Resources">Resources</a>
<li>offset of pinout: <a href="#Resources">Resources</a>
<li>offset of printout: <a href="#Printing">Printing</a>
<li>old library: <a href="#Element%20Objects">Element Objects</a>
<li>OpenWindows: <a href="#Sun">Sun</a>
<li>operation modes, selecting of: <a href="#Actions">Actions</a>
<li>optimizer: <a href="#Trace%20Optimizer">Trace Optimizer</a>
<li>outline printout: <a href="#Printing">Printing</a>
<li>output device: <a href="#Printing">Printing</a>
<li>outputline, length of: <a href="#Options">Options</a>
<li>overlap, minimum: <a href="#Design%20Rule%20Checking">Design Rule Checking</a>
<li>Panner control: <a href="#Panner%20Control">Panner Control</a>
<li>pastebuffer, an example: <a href="#Pastebuffer">Pastebuffer</a>
<li>pastebuffer, convert contents to element: <a href="#Elements">Elements</a>
<li>pastebuffer, popup menu: <a href="#Menu">Menu</a>
<li>pastebuffer, selecting a: <a href="#Actions">Actions</a>
<li>path for element files: <a href="#Resources">Resources</a>
<li>path for font files: <a href="#Resources">Resources</a>
<li>path for layout files: <a href="#Resources">Resources</a>
<li>path for libraries: <a href="#Resources">Resources</a>
<li>PC UNIX: <a href="#SCO">SCO</a>, <a href="#Linux">Linux</a>, <a href="#BSD">BSD</a>
<li>PCB, an overview: <a href="#Overview">Overview</a>
<li>pin color: <a href="#Resources">Resources</a>
<li>pin, name of: <a href="#Resources">Resources</a>, <a href="#Options">Options</a>
<li>pinout, display of: <a href="#Actions">Actions</a>
<li>pinout, font to display pin names: <a href="#Resources">Resources</a>
<li>pinout, zoomfactor of display: <a href="#Options">Options</a>, <a href="#Resources">Resources</a>
<li>pins, an example: <a href="#Elements">Elements</a>
<li>pins, changing shape of: <a href="#Actions">Actions</a>
<li>pointer, moving of: <a href="#Actions">Actions</a>
<li>polygon: <a href="#Resources">Resources</a>
<li>polygon point, go back to previous: <a href="#Actions">Actions</a>
<li>polygon, an example: <a href="#Polygons">Polygons</a>
<li>polygon, an overview: <a href="#Polygon%20Objects">Polygon Objects</a>
<li>polygon, closing a: <a href="#Actions">Actions</a>
<li>popping up menus: <a href="#Menu">Menu</a>
<li>postprocessing layout data: <a href="#Resources">Resources</a>, <a href="#Options">Options</a>
<li>preprocessing element data: <a href="#Resources">Resources</a>, <a href="#Options">Options</a>
<li>preprocessing font data: <a href="#Resources">Resources</a>, <a href="#Options">Options</a>
<li>preprocessing layout data: <a href="#Resources">Resources</a>, <a href="#Options">Options</a>
<li>preventing loss of data: <a href="#Options">Options</a>, <a href="#Resources">Resources</a>, <a href="#Loading%20and%20Saving">Loading and Saving</a>
<li>print command: <a href="#Printing">Printing</a>
<li>print media: <a href="#Printing">Printing</a>, <a href="#Resources">Resources</a>
<li>print offset: <a href="#Printing">Printing</a>
<li>printing: <a href="#Resources">Resources</a>
<li>printing a layout: <a href="#Actions">Actions</a>
<li>printing, an example: <a href="#Printing">Printing</a>
<li>problems: <a href="#problems">problems</a>
<li>quit: <a href="#Actions">Actions</a>, <a href="#User%20Commands">User Commands</a>
<li>rat's nest: <a href="#User%20Commands">User Commands</a>
<li>rat-line: <a href="#Rats%20Nest">Rats Nest</a>, <a href="#Actions">Actions</a>
<li>rats nest: <a href="#Resources">Resources</a>, <a href="#Rats%20Nest">Rats Nest</a>, <a href="#Actions">Actions</a>
<li>rats-nest: <a href="#Net%20Objects">Net Objects</a>
<li>recover: <a href="#Actions">Actions</a>
<li>rectangle, an example: <a href="#Polygons">Polygons</a>
<li>redo: <a href="#Actions">Actions</a>, <a href="#Menu">Menu</a>
<li>redrawing layout: <a href="#Actions">Actions</a>
<li>refreshing layout: <a href="#Actions">Actions</a>
<li>release, current: <a href="#Special%20Options">Special Options</a>
<li>removing connections: <a href="#Translations">Translations</a>
<li>removing objects: <a href="#Common">Common</a>, <a href="#Translations">Translations</a>, <a href="#Drawing%20and%20Removing">Drawing and Removing</a>
<li>removing selected objects: <a href="#Actions">Actions</a>
<li>report: <a href="#Actions">Actions</a>, <a href="#Menu">Menu</a>
<li>reseting found connections: <a href="#Options">Options</a>, <a href="#Resources">Resources</a>, <a href="#Actions">Actions</a>
<li>resources: <a href="#Resources">Resources</a>
<li>rotate: <a href="#Resources">Resources</a>
<li>rotating a buffer: <a href="#Actions">Actions</a>
<li>rotating printout: <a href="#Printing">Printing</a>
<li>routing style: <a href="#Resources">Resources</a>, <a href="#Actions">Actions</a>, <a href="#Options">Options</a>
<li>rubber band: <a href="#Menu">Menu</a>
<li>rubberband: <a href="#Actions">Actions</a>, <a href="#Resources">Resources</a>
<li>saving connections: <a href="#Actions">Actions</a>
<li>saving files: <a href="#Actions">Actions</a>
<li>saving found connections: <a href="#Actions">Actions</a>
<li>saving last entered user command: <a href="#Resources">Resources</a>, <a href="#Options">Options</a>
<li>saving layouts: <a href="#Options">Options</a>, <a href="#User%20Commands">User Commands</a>, <a href="#Resources">Resources</a>, <a href="#Options">Options</a>, <a href="#Resources">Resources</a>, <a href="#Loading%20and%20Saving">Loading and Saving</a>
<li>saving, an example: <a href="#Loading%20and%20Saving">Loading and Saving</a>
<li>scaling a printout: <a href="#Printing">Printing</a>
<li>scanning connections: <a href="#Actions">Actions</a>
<li>schematic capture: <a href="#Schematic%20Frontends">Schematic Frontends</a>
<li>schematic frontend: <a href="#Schematic%20Frontends">Schematic Frontends</a>
<li>SCO: <a href="#SCO">SCO</a>
<li>Screen, popup menu: <a href="#Menu">Menu</a>
<li>scrolling: <a href="#Translations">Translations</a>
<li>searching connections: <a href="#Actions">Actions</a>
<li>searchpath for element files: <a href="#Resources">Resources</a>
<li>searchpath for font files: <a href="#Resources">Resources</a>
<li>searchpath for layout files: <a href="#Resources">Resources</a>
<li>searchpath for libraries: <a href="#Resources">Resources</a>
<li>Select, popup menu: <a href="#Menu">Menu</a>
<li>selected object, removing an: <a href="#Actions">Actions</a>
<li>selected objects, changing sizes: <a href="#Menu">Menu</a>
<li>selected objects, removing: <a href="#Menu">Menu</a>
<li>selecting a buffer: <a href="#Actions">Actions</a>
<li>selecting a new tool: <a href="#Tool%20Selectors">Tool Selectors</a>
<li>selecting objects: <a href="#Actions">Actions</a>
<li>selecting, using the arrow tool: <a href="#Arrow%20Tool">Arrow Tool</a>
<li>selection: <a href="#Actions">Actions</a>
<li>Settings, popup menu: <a href="#Menu">Menu</a>
<li>SGI: <a href="#SGI">SGI</a>
<li>shrink: <a href="#Resources">Resources</a>
<li>signal: <a href="#Actions">Actions</a>
<li>Silicon Graphics: <a href="#SGI">SGI</a>
<li>size of a layout: <a href="#Options">Options</a>
<li>size of lines: <a href="#Resources">Resources</a>
<li>size of lines and vias: <a href="#Actions">Actions</a>
<li>size of vias: <a href="#Resources">Resources</a>
<li>sizes, changing of objects: <a href="#Actions">Actions</a>
<li>Sizes, popup menu: <a href="#Menu">Menu</a>
<li>snap to pins: <a href="#Menu">Menu</a>
<li>Solaris: <a href="#Sun">Sun</a>
<li>solder mask, viewing and editing: <a href="#Menu">Menu</a>
<li>spacing, minimum: <a href="#Design%20Rule%20Checking">Design Rule Checking</a>
<li>speaker volume: <a href="#Resources">Resources</a>, <a href="#Options">Options</a>
<li>square flag, changing: <a href="#Actions">Actions</a>
<li>square flag, changing of objects: <a href="#Actions">Actions</a>
<li>square flag, clearing: <a href="#Actions">Actions</a>
<li>square flag, setting: <a href="#Actions">Actions</a>
<li>start user input: <a href="#Actions">Actions</a>
<li>starting a new layout: <a href="#Actions">Actions</a>
<li>starting <code>Pcb</code>: <a href="#Command-Line%20Options">Command-Line Options</a>
<li>status information: <a href="#Status-line%20and%20Input-field">Status-line and Input-field</a>
<li>strings, an example: <a href="#Text">Text</a>
<li>strings, an overview: <a href="#Text%20Objects">Text Objects</a>
<li>Sun: <a href="#Sun">Sun</a>
<li>symbols: <a href="#Resources">Resources</a>, <a href="#Options">Options</a>
<li>symbols, an overview: <a href="#Symbol%20Objects">Symbol Objects</a>
<li>temporary files: <a href="#Resources">Resources</a>, <a href="#Loading%20and%20Saving">Loading and Saving</a>, <a href="#Options">Options</a>
<li>TeX, problems: <a href="#TeX%20and%20Manuals">TeX and Manuals</a>
<li>text, an example: <a href="#Text">Text</a>
<li>text, an overview: <a href="#Text%20Objects">Text Objects</a>
<li>text, default scaling: <a href="#Resources">Resources</a>
<li>thermal flag, changing: <a href="#Actions">Actions</a>
<li>thermal flag, clearing: <a href="#Actions">Actions</a>
<li>thermal flag, setting: <a href="#Actions">Actions</a>
<li>thickness of lines: <a href="#Resources">Resources</a>
<li>thickness of objects: <a href="#Common">Common</a>
<li>thickness of vias: <a href="#Resources">Resources</a>
<li>thickness, changing of objects: <a href="#Actions">Actions</a>
<li>toggle layer visilibility: <a href="#Actions">Actions</a>
<li>tool selection: <a href="#Tool%20Selectors">Tool Selectors</a>
<li>tool, arrow: <a href="#Arrow%20Tool">Arrow Tool</a>
<li>trace optimizer: <a href="#Trace%20Optimizer">Trace Optimizer</a>
<li>translations: <a href="#Actions">Actions</a>, <a href="#Translations">Translations</a>
<li>troubleshooting: <a href="#problems">problems</a>
<li>two line mode: <a href="#Line%20Objects">Line Objects</a>
<li>undo: <a href="#Actions">Actions</a>, <a href="#Menu">Menu</a>
<li>undo, multi-action resources: <a href="#Actions">Actions</a>
<li>unique names: <a href="#Menu">Menu</a>
<li>unix command: <a href="#Resources">Resources</a>, <a href="#Options">Options</a>, <a href="#Resources">Resources</a>, <a href="#Options">Options</a>, <a href="#Resources">Resources</a>, <a href="#Options">Options</a>, <a href="#Resources">Resources</a>, <a href="#Options">Options</a>
<li>unselect objects: <a href="#Actions">Actions</a>
<li>user commands: <a href="#User%20Commands">User Commands</a>
<li>user input: <a href="#Translations">Translations</a>
<li>version, current: <a href="#Special%20Options">Special Options</a>
<li>vias, an example: <a href="#Vias">Vias</a>
<li>vias, an overview: <a href="#Via%20Objects">Via Objects</a>
<li>vias, changing shape of: <a href="#Actions">Actions</a>
<li>vias, color: <a href="#Resources">Resources</a>
<li>vias, converting to mounting hole: <a href="#Actions">Actions</a>
<li>vias, setting of initial size: <a href="#Actions">Actions</a>
<li>vias, size: <a href="#Resources">Resources</a>
<li>View, adjusting: <a href="#Panner%20Control">Panner Control</a>
<li>viewing side, changing of: <a href="#Actions">Actions</a>
<li>volume of speaker: <a href="#Resources">Resources</a>, <a href="#Options">Options</a>
<li>Window, popup menu: <a href="#Menu">Menu</a>
<li>X11: <a href="#X11%20Interface">X11 Interface</a>
<li>X11 default translations: <a href="#Translations">Translations</a>
<li>X11 resources: <a href="#Resources">Resources</a>
<li>X11 translations: <a href="#Actions">Actions</a>
<li>X11, problems: <a href="#X11">X11</a>
<li>xcircuit, how to interface with: <a href="#xcircuit">xcircuit</a>
<li>zoom of Layout area: <a href="#Resources">Resources</a>
<li>zoom of pinout window: <a href="#Options">Options</a>, <a href="#Resources">Resources</a>
<li>zoom, setting: <a href="#Menu">Menu</a>
<li>zoom, setting of: <a href="#Actions">Actions</a>
</ul>

<h1>Table of Contents</h1>
<ul>
<li><a href="#Top">Pcb</a>
<li><a href="#Copying">Copying</a>
<li><a href="#History">History</a>
<li><a href="#Overview">Overview</a>
<li><a href="#Intro">Introduction</a>
<ul>
<li><a href="#Symbol%20Objects">Symbols</a>
<li><a href="#Via%20Objects">Vias</a>
<li><a href="#Element%20Objects">Elements</a>
<li><a href="#Layer%20Objects">Layers</a>
<li><a href="#Line%20Objects">Lines</a>
<li><a href="#Arc%20Objects">Arcs</a>
<li><a href="#Polygon%20Objects">Polygons</a>
<li><a href="#Text%20Objects">Text</a>
<li><a href="#Net%20Objects">Nets</a>
</ul>
<li><a href="#Getting%20Started">Getting Started</a>
<ul>
<li><a href="#Application%20Window">The Application Window</a>
<ul>
<li><a href="#Menu">Menus</a>
<li><a href="#Status-line%20and%20Input-field">The Status-line and Input-field</a>
<li><a href="#Panner%20Control">The Panner Control</a>
<li><a href="#Layer%20Controls">The Layer Controls</a>
<li><a href="#Tool%20Selectors">The Tool Selectors</a>
<li><a href="#Layout%20Area">Layout Area</a>
</ul>
<li><a href="#Log%20Window">Log Window</a>
<li><a href="#Library%20Window">Library Window</a>
<li><a href="#Netlist%20Window">Netlist Window</a>
<li><a href="#Drawing%20and%20Removing">Drawing and Removing Basic Objects</a>
<ul>
<li><a href="#Lines">Lines</a>
<li><a href="#Arcs">Arcs</a>
<li><a href="#Polygons">Polygons and Rectangles</a>
<li><a href="#Text">Text</a>
<li><a href="#Vias">Vias</a>
<li><a href="#Elements">Elements</a>
<li><a href="#Pastebuffer">Pastebuffer</a>
</ul>
<li><a href="#Moving%20and%20Copying">Moving and Copying</a>
<li><a href="#Loading%20and%20Saving">Loading and Saving</a>
<li><a href="#Printing">Printing</a>
<li><a href="#Connection%20Lists">Connection Lists</a>
<li><a href="#Arrow%20Tool">Arrow Tool</a>
<li><a href="#Rats%20Nest">Rats Nest</a>
<li><a href="#Design%20Rule%20Checking">Design Rule Checking</a>
<li><a href="#Trace%20Optimizer">Trace Optimizer</a>
</ul>
<li><a href="#User%20Commands">User Commands</a>
<li><a href="#Command-Line%20Options">Command-Line Options</a>
<ul>
<li><a href="#Options">Options</a>
<li><a href="#Special%20Options">Special Options</a>
</ul>
<li><a href="#X11%20Interface">X11 Interface</a>
<ul>
<li><a href="#Resources">Non-Standard X11 Application Resources</a>
<li><a href="#Actions">Actions</a>
<li><a href="#Translations">Default Translations</a>
</ul>
<li><a href="#File%20Formats">File Formats</a>
<ul>
<li><a href="#Basic%20Types">Basic Types</a>
<li><a href="#Layout%20File">Layout File Format</a>
<li><a href="#Element%20File">Element File Format</a>
<li><a href="#Font%20File">Font File Format</a>
<li><a href="#Netlist%20File">Netlist File Format</a>
<li><a href="#Library%20Contents%20File">Library Contents File Format</a>
<li><a href="#Library%20File">Library File Format</a>
</ul>
<li><a href="#Library%20Creation">Library Creation</a>
<ul>
<li><a href="#Library%20Creation">Old Style (m4) Libraries</a>
<ul>
<li><a href="#Library%20Creation">Overview of Oldlib Operation</a>
<li><a href="#Library%20Creation">The Library Scripts</a>
<ul>
<li><a href="#Library%20Creation">Scripts Used During Compilation</a>
<li><a href="#Library%20Creation">Scripts Used by PCB at Runtime</a>
</ul>
<li><a href="#Library%20Creation">Creating an Oldlib Footprint</a>
<li><a href="#Library%20Creation">Troubleshooting Old Style Libraries</a>
</ul>
<li><a href="#Library%20Creation">New Style Libraries</a>
<ul>
<li><a href="#Library%20Creation">Creating Newlib Footprints</a>
<li><a href="#Library%20Creation">Modifying Newlib Footprints</a>
</ul>
</ul>
<li><a href="#Schematic%20Frontends">Schematic Capture for PCB</a>
<ul>
<li><a href="#gEDA">gEDA</a>
<ul>
<li><a href="#gEDA">Set Up Project Directories</a>
<li><a href="#gEDA">Set Up gEDA Config Files</a>
<li><a href="#gEDA">Set Up <code>gsch2pcb</code> Config Files</a>
<li><a href="#gEDA">Capture Schematics Using <code>gschem</code></a>
<li><a href="#gEDA">Create Any Unique PCB Footprints</a>
<li><a href="#gEDA">Generate Initial PCB Design Using <code>gsch2pcb</code></a>
<li><a href="#gEDA">Layout Circuit Board</a>
</ul>
<li><a href="#gEDA">Forward Annotation of Schematic Changes</a>
<ul>
<li><a href="#gEDA">Generate Photoplot Files (RS-274-X)</a>
</ul>
<li><a href="#xcircuit">xcircuit</a>
</ul>
<li><a href="#Installation">Installation and Troubleshooting</a>
<ul>
<li><a href="#compiling">Compiling and Installing</a>
<ul>
<li><a href="#quickstart">Quick Start</a>
<li><a href="#running%20configure">Running the configure Script</a>
</ul>
<li><a href="#problems">Troubleshooting</a>
<ul>
<li><a href="#HP">HP Series 700 and 800</a>
<li><a href="#Sun">Sun SPARC architecture</a>
<li><a href="#SGI">Silicon Graphics</a>
<li><a href="#DEC%20Alpha">DEC Alpha</a>
<li><a href="#SCO">SCO Unix</a>
<li><a href="#Linux">Linux</a>
<li><a href="#BSD">FreeBSD and NetBSD</a>
<li><a href="#X11">Problems related to X11</a>
<li><a href="#TeX%20and%20Manuals">Problems related to TeX</a>
</ul>
</ul>
<li><a href="#Custom%20Menus">Customizing the Menus</a>
<ul>
<li><a href="#Resource%20Syntax">Resource Syntax</a>
<li><a href="#Menu%20Definitions">Menu Definitions</a>
<li><a href="#Menu%20Files%20and%20Defaults">Menu Files and Defaults</a>
</ul>
<li><a href="#Index">Index of Resources</a>
<li><a href="#Index">Index of Actions, Commands and Options</a>
<li><a href="#Index">Index of Concepts</a>
</ul>


</body></html>

